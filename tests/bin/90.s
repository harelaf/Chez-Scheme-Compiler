;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 50

section .data
const_tbl:
db T_VOID
db T_NIL
db T_BOOL, 0
db T_BOOL, 1
MAKE_LITERAL_STRING "whatever"
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_CHAR(0)
MAKE_LITERAL_RATIONAL(0,1)
MAKE_LITERAL_RATIONAL(1,1)
MAKE_LITERAL_RATIONAL(-1,1)
MAKE_LITERAL_PAIR(const_tbl+51,const_tbl+1)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+88], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+176], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+312], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+296], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+272], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+120], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+368], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+304], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+376], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+344], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+352], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+360], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+248], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+384], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+112], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+216], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+168], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+152], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+24], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+16], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+40], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+56], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+48], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+288], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+144], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+200], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov [fvar_tbl+80], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+96], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+104], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+128], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
mov [fvar_tbl+320], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
mov [fvar_tbl+328], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
; ScmDef':
; VarFree: map
; ScmApplic': 
; ScmVar'(VarFree): apply
mov rax, qword [fvar_tbl + 80]
push rax
; ScmVar'(VarFree): cons
mov rax, qword [fvar_tbl + 128]
push rax
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 5
; ScmLambdaSimple': 
; Params: null?, car, cdr, cons, apply
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1:
cmp rsi, -1
je end_copy_env_loop1
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1
end_copy_env_loop1:

add_zero_rib_params1:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1
end_copy_params_loop1:
MAKE_CLOSURE(rax, rdx, Lcode1)
jmp Lcont1
Lcode1:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23
push rax
; ScmConst':
mov rax, const_tbl + 23

push rax
push 2
; ScmLambdaSimple': 
; Params: map-many, map-one
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params3

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop3:
cmp rsi, 0
je end_copy_env_loop3
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop3
end_copy_env_loop3:

add_zero_rib_params3:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop3:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop3
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop3
end_copy_params_loop3:
MAKE_CLOSURE(rax, rdx, Lcode3)
jmp Lcont3
Lcode3:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: map-many
; ScmBox':
;ScmVar'(VarParam): map-many
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmSet':
; VarParam: map-one
; ScmBox':
;ScmVar'(VarParam): map-one
mov rax, qword [rbp + 8 * 5]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 40], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: f, lists
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params4

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop4:
cmp rsi, 1
je end_copy_env_loop4
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop4
end_copy_env_loop4:

add_zero_rib_params4:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop4:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop4
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop4
end_copy_params_loop4:
MAKE_CLOSURE(rax, rdx, Lcode4)
jmp Lcont4
Lcode4:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lists
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure7
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure7:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure6
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure6:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse5
; ScmConst':
mov rax, const_tbl + 1
jmp Lexit5
Lelse5:
; ScmApplicTP': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lists
mov rax, qword [rbp + 8 * 5]
push rax
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): map-one
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure10
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure10:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): f
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): map-many
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure9
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure9:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lists
mov rax, qword [rbp + 8 * 5]
push rax
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): map-one
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure12
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure12:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): f
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): apply
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure11
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure11:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarBound): cons
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure8
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure8:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop8:
cmp rsi, 56
je end_copy_stack_loop8
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop8
end_copy_stack_loop8:
add rsp, rdi
pop rbp
jmp rax
Lexit5:
leave
ret
Lcont4:
mov rbx, rax
;ScmVar'(VarParam): map-many
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: f, s
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params13

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop13:
cmp rsi, 1
je end_copy_env_loop13
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop13
end_copy_env_loop13:

add_zero_rib_params13:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop13:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop13
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop13
end_copy_params_loop13:
MAKE_CLOSURE(rax, rdx, Lcode13)
jmp Lcont13
Lcode13:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): s
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure15
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure15:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse14
; ScmConst':
mov rax, const_tbl + 1
jmp Lexit14
Lelse14:
; ScmApplicTP': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): s
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure18
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure18:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): f
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): map-one
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure17
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure17:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): s
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure20
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure20:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
;ScmVar'(VarParam): f
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure19
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure19:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarBound): cons
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure16
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure16:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop16:
cmp rsi, 56
je end_copy_stack_loop16
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop16
end_copy_stack_loop16:
add rsp, rdi
pop rbp
jmp rax
Lexit14:
leave
ret
Lcont13:
mov rbx, rax
;ScmVar'(VarParam): map-one
mov rax, qword [rbp + 8 * 5]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmLambdaOpt': 
; Params: f
; Optional Param: args
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params21

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop21:
cmp rsi, 1
je end_copy_env_loop21
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop21
end_copy_env_loop21:

add_zero_rib_params21:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop21:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop21
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop21
end_copy_params_loop21:
MAKE_CLOSURE(rax, rdx, Lcode21)
jmp Lcont21
Lcode21:
push rbp
mov rbp , rsp
mov rbx, 1 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack21

adjust_stack_to_list21:
mov rsi, [rbp + 8 * 3]
sub rsi, 1
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 1
cmp rdx, 0
jne params_length_not_zero21
mov rdx, 1
jmp decided_param_count21
params_length_not_zero21:
mov rdx, rcx
sub rdx, 1
add rdx, 1
decided_param_count21:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop21:
cmp rdi, 0
je end_create_list_loop21
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop21
end_create_list_loop21:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop21:
cmp rdi, 0
je end_push_stack_loop21
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop21
end_push_stack_loop21:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body21

add_nil_to_stack21:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop21:
cmp rdi, 0
je end_add_nil_loop21
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop21
end_add_nil_loop21:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body21:
; ScmApplicTP': 
;ScmVar'(VarParam): args
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): f
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): map-many
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure22
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure22:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop22:
cmp rsi, 56
je end_copy_stack_loop22
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop22
end_copy_stack_loop22:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont21:
leave
ret
Lcont3:
cmp byte [rax], T_CLOSURE
je is_closure2
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure2:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop2:
cmp rsi, 56
je end_copy_stack_loop2
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop2
end_copy_stack_loop2:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont1:
cmp byte [rax], T_CLOSURE
je is_closure0
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure0:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 256], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: fold-left
; ScmApplic': 
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 3
; ScmLambdaSimple': 
; Params: null?, car, cdr
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params24

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop24:
cmp rsi, -1
je end_copy_env_loop24
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop24
end_copy_env_loop24:

add_zero_rib_params24:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop24:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop24
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop24
end_copy_params_loop24:
MAKE_CLOSURE(rax, rdx, Lcode24)
jmp Lcont24
Lcode24:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: proc, init, lst
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params25

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop25:
cmp rsi, 0
je end_copy_env_loop25
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop25
end_copy_env_loop25:

add_zero_rib_params25:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop25:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop25
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop25
end_copy_params_loop25:
MAKE_CLOSURE(rax, rdx, Lcode25)
jmp Lcont25
Lcode25:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: fold-left-loop
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params27

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop27:
cmp rsi, 1
je end_copy_env_loop27
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop27
end_copy_env_loop27:

add_zero_rib_params27:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop27:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop27
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop27
end_copy_params_loop27:
MAKE_CLOSURE(rax, rdx, Lcode27)
jmp Lcont27
Lcode27:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: fold-left-loop
; ScmBox':
;ScmVar'(VarParam): fold-left-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: proc, init, lst
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params28

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop28:
cmp rsi, 2
je end_copy_env_loop28
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop28
end_copy_env_loop28:

add_zero_rib_params28:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop28:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop28
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop28
end_copy_params_loop28:
MAKE_CLOSURE(rax, rdx, Lcode28)
jmp Lcont28
Lcode28:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 6]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure30
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure30:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse29
;ScmVar'(VarParam): init
mov rax, qword [rbp + 8 * 5]
jmp Lexit29
Lelse29:
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 6]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure32
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure32:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 6]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure34
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure34:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): init
mov rax, qword [rbp + 8 * 5]

push rax
push 2
;ScmVar'(VarParam): proc
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure33
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure33:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): proc
mov rax, qword [rbp + 8 * 4]

push rax
push 3
; ScmBoxGet':
; ScmVar'(VarBound): fold-left-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure31
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure31:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop31:
cmp rsi, 64
je end_copy_stack_loop31
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop31
end_copy_stack_loop31:
add rsp, rdi
pop rbp
jmp rax
Lexit29:
leave
ret
Lcont28:
mov rbx, rax
;ScmVar'(VarParam): fold-left-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmApplicTP': 
; ScmVar'(VarBound): lst
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
push rax
; ScmVar'(VarBound): init
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
push rax
; ScmVar'(VarBound): proc
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 3
; ScmBoxGet':
;ScmVar'(VarParam): fold-left-loop
mov rax, qword [rbp + 8 * 4]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure35
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure35:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop35:
cmp rsi, 64
je end_copy_stack_loop35
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop35
end_copy_stack_loop35:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont27:
cmp byte [rax], T_CLOSURE
je is_closure26
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure26:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop26:
cmp rsi, 48
je end_copy_stack_loop26
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop26
end_copy_stack_loop26:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont25:
leave
ret
Lcont24:
cmp byte [rax], T_CLOSURE
je is_closure23
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure23:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 184], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: fold-right
; ScmApplic': 
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 3
; ScmLambdaSimple': 
; Params: null?, car, cdr
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params37

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop37:
cmp rsi, -1
je end_copy_env_loop37
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop37
end_copy_env_loop37:

add_zero_rib_params37:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop37:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop37
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop37
end_copy_params_loop37:
MAKE_CLOSURE(rax, rdx, Lcode37)
jmp Lcont37
Lcode37:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: proc, init, lst
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params38

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop38:
cmp rsi, 0
je end_copy_env_loop38
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop38
end_copy_env_loop38:

add_zero_rib_params38:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop38:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop38
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop38
end_copy_params_loop38:
MAKE_CLOSURE(rax, rdx, Lcode38)
jmp Lcont38
Lcode38:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: fold-right-loop
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params40

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop40:
cmp rsi, 1
je end_copy_env_loop40
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop40
end_copy_env_loop40:

add_zero_rib_params40:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop40:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop40
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop40
end_copy_params_loop40:
MAKE_CLOSURE(rax, rdx, Lcode40)
jmp Lcont40
Lcode40:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: fold-right-loop
; ScmBox':
;ScmVar'(VarParam): fold-right-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: proc, init, lst
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params41

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop41:
cmp rsi, 2
je end_copy_env_loop41
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop41
end_copy_env_loop41:

add_zero_rib_params41:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop41:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop41
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop41
end_copy_params_loop41:
MAKE_CLOSURE(rax, rdx, Lcode41)
jmp Lcont41
Lcode41:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 6]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure43
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure43:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse42
;ScmVar'(VarParam): init
mov rax, qword [rbp + 8 * 5]
jmp Lexit42
Lelse42:
; ScmApplicTP': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 6]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure46
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure46:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): init
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): proc
mov rax, qword [rbp + 8 * 4]

push rax
push 3
; ScmBoxGet':
; ScmVar'(VarBound): fold-right-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure45
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure45:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 6]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure47
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure47:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
;ScmVar'(VarParam): proc
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure44
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure44:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop44:
cmp rsi, 56
je end_copy_stack_loop44
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop44
end_copy_stack_loop44:
add rsp, rdi
pop rbp
jmp rax
Lexit42:
leave
ret
Lcont41:
mov rbx, rax
;ScmVar'(VarParam): fold-right-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmApplicTP': 
; ScmVar'(VarBound): lst
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
push rax
; ScmVar'(VarBound): init
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
push rax
; ScmVar'(VarBound): proc
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 3
; ScmBoxGet':
;ScmVar'(VarParam): fold-right-loop
mov rax, qword [rbp + 8 * 4]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure48
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure48:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop48:
cmp rsi, 64
je end_copy_stack_loop48
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop48
end_copy_stack_loop48:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont40:
cmp byte [rax], T_CLOSURE
je is_closure39
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure39:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop39:
cmp rsi, 48
je end_copy_stack_loop39
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop39
end_copy_stack_loop39:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont38:
leave
ret
Lcont37:
cmp byte [rax], T_CLOSURE
je is_closure36
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure36:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 192], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: without-last-elem
; ScmApplic': 
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 3
; ScmLambdaSimple': 
; Params: null?, car, cdr
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params50

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop50:
cmp rsi, -1
je end_copy_env_loop50
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop50
end_copy_env_loop50:

add_zero_rib_params50:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop50:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop50
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop50
end_copy_params_loop50:
MAKE_CLOSURE(rax, rdx, Lcode50)
jmp Lcont50
Lcode50:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: lst
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params51

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop51:
cmp rsi, 0
je end_copy_env_loop51
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop51
end_copy_env_loop51:

add_zero_rib_params51:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop51:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop51
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop51
end_copy_params_loop51:
MAKE_CLOSURE(rax, rdx, Lcode51)
jmp Lcont51
Lcode51:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: without-last-elem-loop
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params53

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop53:
cmp rsi, 1
je end_copy_env_loop53
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop53
end_copy_env_loop53:

add_zero_rib_params53:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop53:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop53
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop53
end_copy_params_loop53:
MAKE_CLOSURE(rax, rdx, Lcode53)
jmp Lcont53
Lcode53:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: without-last-elem-loop
; ScmBox':
;ScmVar'(VarParam): without-last-elem-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: lst
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params54

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop54:
cmp rsi, 2
je end_copy_env_loop54
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop54
end_copy_env_loop54:

add_zero_rib_params54:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop54:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop54
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop54
end_copy_params_loop54:
MAKE_CLOSURE(rax, rdx, Lcode54)
jmp Lcont54
Lcode54:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure57
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure57:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure56
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure56:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse55
; ScmConst':
mov rax, const_tbl + 1
jmp Lexit55
Lelse55:
; ScmApplicTP': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure60
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure60:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmBoxGet':
; ScmVar'(VarBound): without-last-elem-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure59
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure59:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure61
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure61:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarFree): cons
mov rax, qword [fvar_tbl + 128]
cmp byte [rax], T_CLOSURE
je is_closure58
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure58:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop58:
cmp rsi, 56
je end_copy_stack_loop58
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop58
end_copy_stack_loop58:
add rsp, rdi
pop rbp
jmp rax
Lexit55:
leave
ret
Lcont54:
mov rbx, rax
;ScmVar'(VarParam): without-last-elem-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmApplicTP': 
; ScmVar'(VarBound): lst
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmBoxGet':
;ScmVar'(VarParam): without-last-elem-loop
mov rax, qword [rbp + 8 * 4]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure62
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure62:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop62:
cmp rsi, 48
je end_copy_stack_loop62
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop62
end_copy_stack_loop62:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont53:
cmp byte [rax], T_CLOSURE
je is_closure52
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure52:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop52:
cmp rsi, 48
je end_copy_stack_loop52
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop52
end_copy_stack_loop52:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont51:
leave
ret
Lcont50:
cmp byte [rax], T_CLOSURE
je is_closure49
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure49:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 0], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: last-elem
; ScmApplic': 
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 3
; ScmLambdaSimple': 
; Params: null?, car, cdr
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params64

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop64:
cmp rsi, -1
je end_copy_env_loop64
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop64
end_copy_env_loop64:

add_zero_rib_params64:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop64:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop64
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop64
end_copy_params_loop64:
MAKE_CLOSURE(rax, rdx, Lcode64)
jmp Lcont64
Lcode64:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: lst
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params65

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop65:
cmp rsi, 0
je end_copy_env_loop65
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop65
end_copy_env_loop65:

add_zero_rib_params65:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop65:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop65
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop65
end_copy_params_loop65:
MAKE_CLOSURE(rax, rdx, Lcode65)
jmp Lcont65
Lcode65:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: last-elem-loop
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params67

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop67:
cmp rsi, 1
je end_copy_env_loop67
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop67
end_copy_env_loop67:

add_zero_rib_params67:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop67:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop67
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop67
end_copy_params_loop67:
MAKE_CLOSURE(rax, rdx, Lcode67)
jmp Lcont67
Lcode67:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: last-elem-loop
; ScmBox':
;ScmVar'(VarParam): last-elem-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: lst
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params68

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop68:
cmp rsi, 2
je end_copy_env_loop68
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop68
end_copy_env_loop68:

add_zero_rib_params68:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop68:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop68
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop68
end_copy_params_loop68:
MAKE_CLOSURE(rax, rdx, Lcode68)
jmp Lcont68
Lcode68:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure71
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure71:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure70
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure70:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse69
; ScmApplicTP': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure72
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure72:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop72:
cmp rsi, 48
je end_copy_stack_loop72
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop72
end_copy_stack_loop72:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit69
Lelse69:
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure74
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure74:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmBoxGet':
; ScmVar'(VarBound): last-elem-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure73
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure73:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop73:
cmp rsi, 48
je end_copy_stack_loop73
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop73
end_copy_stack_loop73:
add rsp, rdi
pop rbp
jmp rax
Lexit69:
leave
ret
Lcont68:
mov rbx, rax
;ScmVar'(VarParam): last-elem-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmApplicTP': 
; ScmVar'(VarBound): lst
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmBoxGet':
;ScmVar'(VarParam): last-elem-loop
mov rax, qword [rbp + 8 * 4]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure75
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure75:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop75:
cmp rsi, 48
je end_copy_stack_loop75
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop75
end_copy_stack_loop75:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont67:
cmp byte [rax], T_CLOSURE
je is_closure66
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure66:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop66:
cmp rsi, 48
je end_copy_stack_loop66
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop66
end_copy_stack_loop66:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont65:
leave
ret
Lcont64:
cmp byte [rax], T_CLOSURE
je is_closure63
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure63:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 8], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: cons*
; ScmApplic': 
; ScmVar'(VarFree): fold-right
mov rax, qword [fvar_tbl + 192]
push rax
; ScmVar'(VarFree): without-last-elem
mov rax, qword [fvar_tbl + 0]
push rax
; ScmVar'(VarFree): last-elem
mov rax, qword [fvar_tbl + 8]
push rax
; ScmVar'(VarFree): cons
mov rax, qword [fvar_tbl + 128]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 5
; ScmLambdaSimple': 
; Params: null?, cons, last-elem, without-last-elem, fold-right
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params77

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop77:
cmp rsi, -1
je end_copy_env_loop77
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop77
end_copy_env_loop77:

add_zero_rib_params77:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop77:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop77
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop77
end_copy_params_loop77:
MAKE_CLOSURE(rax, rdx, Lcode77)
jmp Lcont77
Lcode77:
push rbp
mov rbp , rsp
; ScmLambdaOpt': 
; Params: 
; Optional Param: argslist
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params78

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop78:
cmp rsi, 0
je end_copy_env_loop78
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop78
end_copy_env_loop78:

add_zero_rib_params78:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop78:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop78
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop78
end_copy_params_loop78:
MAKE_CLOSURE(rax, rdx, Lcode78)
jmp Lcont78
Lcode78:
push rbp
mov rbp , rsp
mov rbx, 0 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack78

adjust_stack_to_list78:
mov rsi, [rbp + 8 * 3]
sub rsi, 0
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 0
cmp rdx, 0
jne params_length_not_zero78
mov rdx, 1
jmp decided_param_count78
params_length_not_zero78:
mov rdx, rcx
sub rdx, 0
add rdx, 1
decided_param_count78:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop78:
cmp rdi, 0
je end_create_list_loop78
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop78
end_create_list_loop78:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop78:
cmp rdi, 0
je end_push_stack_loop78
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop78
end_push_stack_loop78:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body78

add_nil_to_stack78:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop78:
cmp rdi, 0
je end_add_nil_loop78
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop78
end_add_nil_loop78:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body78:
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): argslist
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure80
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure80:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse79
; ScmConst':
mov rax, const_tbl + 1
jmp Lexit79
Lelse79:
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): argslist
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): without-last-elem
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure82
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure82:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): argslist
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): last-elem
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure83
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure83:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmVar'(VarBound): cons
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

push rax
push 3
; ScmVar'(VarBound): fold-right
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure81
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure81:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop81:
cmp rsi, 64
je end_copy_stack_loop81
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop81
end_copy_stack_loop81:
add rsp, rdi
pop rbp
jmp rax
Lexit79:
leave
ret
Lcont78:
leave
ret
Lcont77:
cmp byte [rax], T_CLOSURE
je is_closure76
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure76:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 136], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: append
; ScmApplic': 
; ScmVar'(VarFree): cons
mov rax, qword [fvar_tbl + 128]
push rax
; ScmVar'(VarFree): fold-right
mov rax, qword [fvar_tbl + 192]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 3
; ScmLambdaSimple': 
; Params: null?, fold-right, cons
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params85

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop85:
cmp rsi, -1
je end_copy_env_loop85
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop85
end_copy_env_loop85:

add_zero_rib_params85:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop85:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop85
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop85
end_copy_params_loop85:
MAKE_CLOSURE(rax, rdx, Lcode85)
jmp Lcont85
Lcode85:
push rbp
mov rbp , rsp
; ScmLambdaOpt': 
; Params: 
; Optional Param: args
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params86

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop86:
cmp rsi, 0
je end_copy_env_loop86
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop86
end_copy_env_loop86:

add_zero_rib_params86:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop86:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop86
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop86
end_copy_params_loop86:
MAKE_CLOSURE(rax, rdx, Lcode86)
jmp Lcont86
Lcode86:
push rbp
mov rbp , rsp
mov rbx, 0 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack86

adjust_stack_to_list86:
mov rsi, [rbp + 8 * 3]
sub rsi, 0
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 0
cmp rdx, 0
jne params_length_not_zero86
mov rdx, 1
jmp decided_param_count86
params_length_not_zero86:
mov rdx, rcx
sub rdx, 0
add rdx, 1
decided_param_count86:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop86:
cmp rdi, 0
je end_create_list_loop86
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop86
end_create_list_loop86:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop86:
cmp rdi, 0
je end_push_stack_loop86
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop86
end_push_stack_loop86:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body86

add_nil_to_stack86:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop86:
cmp rdi, 0
je end_add_nil_loop86
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop86
end_add_nil_loop86:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body86:
; ScmApplicTP': 
;ScmVar'(VarParam): args
mov rax, qword [rbp + 8 * 4]
push rax
; ScmConst':
mov rax, const_tbl + 1
push rax
; ScmLambdaSimple': 
; Params: e, a
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params88

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop88:
cmp rsi, 1
je end_copy_env_loop88
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop88
end_copy_env_loop88:

add_zero_rib_params88:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop88:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop88
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop88
end_copy_params_loop88:
MAKE_CLOSURE(rax, rdx, Lcode88)
jmp Lcont88
Lcode88:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): a
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure90
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure90:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse89
;ScmVar'(VarParam): e
mov rax, qword [rbp + 8 * 4]
jmp Lexit89
Lelse89:
; ScmApplicTP': 
;ScmVar'(VarParam): e
mov rax, qword [rbp + 8 * 4]
push rax
;ScmVar'(VarParam): a
mov rax, qword [rbp + 8 * 5]
push rax
; ScmVar'(VarBound): cons
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]

push rax
push 3
; ScmVar'(VarBound): fold-right
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure91
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure91:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop91:
cmp rsi, 64
je end_copy_stack_loop91
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop91
end_copy_stack_loop91:
add rsp, rdi
pop rbp
jmp rax
Lexit89:
leave
ret
Lcont88:

push rax
push 3
; ScmVar'(VarBound): fold-right
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure87
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure87:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop87:
cmp rsi, 64
je end_copy_stack_loop87
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop87
end_copy_stack_loop87:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont86:
leave
ret
Lcont85:
cmp byte [rax], T_CLOSURE
je is_closure84
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure84:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 72], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: list
; ScmLambdaOpt': 
; Params: 
; Optional Param: x
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params92

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop92:
cmp rsi, -1
je end_copy_env_loop92
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop92
end_copy_env_loop92:

add_zero_rib_params92:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop92:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop92
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop92
end_copy_params_loop92:
MAKE_CLOSURE(rax, rdx, Lcode92)
jmp Lcont92
Lcode92:
push rbp
mov rbp , rsp
mov rbx, 0 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack92

adjust_stack_to_list92:
mov rsi, [rbp + 8 * 3]
sub rsi, 0
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 0
cmp rdx, 0
jne params_length_not_zero92
mov rdx, 1
jmp decided_param_count92
params_length_not_zero92:
mov rdx, rcx
sub rdx, 0
add rdx, 1
decided_param_count92:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop92:
cmp rdi, 0
je end_create_list_loop92
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop92
end_create_list_loop92:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop92:
cmp rdi, 0
je end_push_stack_loop92
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop92
end_push_stack_loop92:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body92

add_nil_to_stack92:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop92:
cmp rdi, 0
je end_add_nil_loop92
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop92
end_add_nil_loop92:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body92:
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
leave
ret
Lcont92:
mov qword [fvar_tbl + 232], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: list?
; ScmApplic': 
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): pair?
mov rax, qword [fvar_tbl + 296]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 3
; ScmLambdaSimple': 
; Params: null?, pair?, cdr
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params94

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop94:
cmp rsi, -1
je end_copy_env_loop94
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop94
end_copy_env_loop94:

add_zero_rib_params94:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop94:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop94
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop94
end_copy_params_loop94:
MAKE_CLOSURE(rax, rdx, Lcode94)
jmp Lcont94
Lcode94:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: list?-loop
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params96

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop96:
cmp rsi, 0
je end_copy_env_loop96
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop96
end_copy_env_loop96:

add_zero_rib_params96:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop96:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop96
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop96
end_copy_params_loop96:
MAKE_CLOSURE(rax, rdx, Lcode96)
jmp Lcont96
Lcode96:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: list?-loop
; ScmBox':
;ScmVar'(VarParam): list?-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: x
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params97

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop97:
cmp rsi, 1
je end_copy_env_loop97
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop97
end_copy_env_loop97:

add_zero_rib_params97:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop97:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop97
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop97
end_copy_params_loop97:
MAKE_CLOSURE(rax, rdx, Lcode97)
jmp Lcont97
Lcode97:
push rbp
mov rbp , rsp
; ScmOr': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure99
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure99:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
jne Lexit98
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): pair?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure101
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure101:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse100
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure103
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure103:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmBoxGet':
; ScmVar'(VarBound): list?-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure102
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure102:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop102:
cmp rsi, 48
je end_copy_stack_loop102
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop102
end_copy_stack_loop102:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit100
Lelse100:
; ScmConst':
mov rax, const_tbl + 2
Lexit100:
Lexit98:
leave
ret
Lcont97:
mov rbx, rax
;ScmVar'(VarParam): list?-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmBoxGet':
;ScmVar'(VarParam): list?-loop
mov rax, qword [rbp + 8 * 4]
CAR rax, rax
leave
ret
Lcont96:
cmp byte [rax], T_CLOSURE
je is_closure95
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure95:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop95:
cmp rsi, 48
je end_copy_stack_loop95
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop95
end_copy_stack_loop95:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont94:
cmp byte [rax], T_CLOSURE
je is_closure93
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure93:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 240], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: make-string
; ScmApplic': 
; ScmVar'(VarFree): make-string
mov rax, qword [fvar_tbl + 248]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 3
; ScmLambdaSimple': 
; Params: null?, car, make-string
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params105

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop105:
cmp rsi, -1
je end_copy_env_loop105
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop105
end_copy_env_loop105:

add_zero_rib_params105:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop105:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop105
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop105
end_copy_params_loop105:
MAKE_CLOSURE(rax, rdx, Lcode105)
jmp Lcont105
Lcode105:
push rbp
mov rbp , rsp
; ScmLambdaOpt': 
; Params: x
; Optional Param: y
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params106

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop106:
cmp rsi, 0
je end_copy_env_loop106
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop106
end_copy_env_loop106:

add_zero_rib_params106:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop106:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop106
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop106
end_copy_params_loop106:
MAKE_CLOSURE(rax, rdx, Lcode106)
jmp Lcont106
Lcode106:
push rbp
mov rbp , rsp
mov rbx, 1 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack106

adjust_stack_to_list106:
mov rsi, [rbp + 8 * 3]
sub rsi, 1
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 1
cmp rdx, 0
jne params_length_not_zero106
mov rdx, 1
jmp decided_param_count106
params_length_not_zero106:
mov rdx, rcx
sub rdx, 1
add rdx, 1
decided_param_count106:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop106:
cmp rdi, 0
je end_create_list_loop106
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop106
end_create_list_loop106:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop106:
cmp rdi, 0
je end_push_stack_loop106
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop106
end_push_stack_loop106:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body106

add_nil_to_stack106:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop106:
cmp rdi, 0
je end_add_nil_loop106
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop106
end_add_nil_loop106:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body106:
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure108
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure108:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse107
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 32
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): make-string
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure109
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure109:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop109:
cmp rsi, 56
je end_copy_stack_loop109
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop109
end_copy_stack_loop109:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit107
Lelse107:
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure111
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure111:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): make-string
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure110
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure110:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop110:
cmp rsi, 56
je end_copy_stack_loop110
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop110
end_copy_stack_loop110:
add rsp, rdi
pop rbp
jmp rax
Lexit107:
leave
ret
Lcont106:
leave
ret
Lcont105:
cmp byte [rax], T_CLOSURE
je is_closure104
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure104:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 248], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: not
; ScmLambdaSimple': 
; Params: x
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params112

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop112:
cmp rsi, -1
je end_copy_env_loop112
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop112
end_copy_env_loop112:

add_zero_rib_params112:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop112:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop112
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop112
end_copy_params_loop112:
MAKE_CLOSURE(rax, rdx, Lcode112)
jmp Lcont112
Lcode112:
push rbp
mov rbp , rsp
; ScmIf': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
cmp rax, SOB_FALSE_ADDRESS
je Lelse113
; ScmConst':
mov rax, const_tbl + 2
jmp Lexit113
Lelse113:
; ScmConst':
mov rax, const_tbl + 4
Lexit113:
leave
ret
Lcont112:
mov qword [fvar_tbl + 264], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmApplic': 
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]
push rax
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): <
mov rax, qword [fvar_tbl + 48]
push rax
; ScmVar'(VarFree): =
mov rax, qword [fvar_tbl + 56]
push rax
; ScmVar'(VarFree): /
mov rax, qword [fvar_tbl + 40]
push rax
; ScmVar'(VarFree): *
mov rax, qword [fvar_tbl + 16]
push rax
; ScmVar'(VarFree): +
mov rax, qword [fvar_tbl + 24]
push rax
; ScmVar'(VarFree): map
mov rax, qword [fvar_tbl + 256]
push rax
; ScmVar'(VarFree): fold-left
mov rax, qword [fvar_tbl + 184]
push rax
; ScmVar'(VarFree): exact->inexact
mov rax, qword [fvar_tbl + 168]
push rax
; ScmVar'(VarFree): rational?
mov rax, qword [fvar_tbl + 312]
push rax
; ScmVar'(VarFree): flonum?
mov rax, qword [fvar_tbl + 176]

push rax
push 13
; ScmLambdaSimple': 
; Params: flonum?, rational?, exact->inexact, fold-left, map, _+, _*, _/, _=, _<, car, cdr, null?
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params115

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop115:
cmp rsi, -1
je end_copy_env_loop115
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop115
end_copy_env_loop115:

add_zero_rib_params115:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop115:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop115
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop115
end_copy_params_loop115:
MAKE_CLOSURE(rax, rdx, Lcode115)
jmp Lcont115
Lcode115:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmLambdaSimple': 
; Params: op
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params152

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop152:
cmp rsi, 0
je end_copy_env_loop152
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop152
end_copy_env_loop152:

add_zero_rib_params152:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop152:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop152
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop152
end_copy_params_loop152:
MAKE_CLOSURE(rax, rdx, Lcode152)
jmp Lcont152
Lcode152:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: x, y
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params153

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop153:
cmp rsi, 1
je end_copy_env_loop153
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop153
end_copy_env_loop153:

add_zero_rib_params153:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop153:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop153
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop153
end_copy_params_loop153:
MAKE_CLOSURE(rax, rdx, Lcode153)
jmp Lcont153
Lcode153:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): flonum?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure156
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure156:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse155
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): rational?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure157
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure157:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
jmp Lexit155
Lelse155:
; ScmConst':
mov rax, const_tbl + 2
Lexit155:
cmp rax, SOB_FALSE_ADDRESS
je Lelse154
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): exact->inexact
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure159
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure159:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): op
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure158
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure158:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop158:
cmp rsi, 56
je end_copy_stack_loop158
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop158
end_copy_stack_loop158:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit154
Lelse154:
; ScmIf': 
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): rational?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure162
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure162:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse161
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): flonum?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure163
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure163:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
jmp Lexit161
Lelse161:
; ScmConst':
mov rax, const_tbl + 2
Lexit161:
cmp rax, SOB_FALSE_ADDRESS
je Lelse160
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): exact->inexact
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure165
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure165:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarBound): op
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure164
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure164:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop164:
cmp rsi, 56
je end_copy_stack_loop164
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop164
end_copy_stack_loop164:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit160
Lelse160:
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): op
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure166
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure166:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop166:
cmp rsi, 56
je end_copy_stack_loop166
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop166
end_copy_stack_loop166:
add rsp, rdi
pop rbp
jmp rax
Lexit160:
Lexit154:
leave
ret
Lcont153:
leave
ret
Lcont152:

push rax
push 1
; ScmLambdaSimple': 
; Params: ^numeric-op-dispatcher
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params117

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop117:
cmp rsi, 0
je end_copy_env_loop117
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop117
end_copy_env_loop117:

add_zero_rib_params117:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop117:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop117
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop117
end_copy_params_loop117:
MAKE_CLOSURE(rax, rdx, Lcode117)
jmp Lcont117
Lcode117:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarFree: +
; ScmLambdaOpt': 
; Params: 
; Optional Param: x
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params118

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop118:
cmp rsi, 1
je end_copy_env_loop118
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop118
end_copy_env_loop118:

add_zero_rib_params118:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop118:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop118
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop118
end_copy_params_loop118:
MAKE_CLOSURE(rax, rdx, Lcode118)
jmp Lcont118
Lcode118:
push rbp
mov rbp , rsp
mov rbx, 0 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack118

adjust_stack_to_list118:
mov rsi, [rbp + 8 * 3]
sub rsi, 0
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 0
cmp rdx, 0
jne params_length_not_zero118
mov rdx, 1
jmp decided_param_count118
params_length_not_zero118:
mov rdx, rcx
sub rdx, 0
add rdx, 1
decided_param_count118:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop118:
cmp rdi, 0
je end_create_list_loop118
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop118
end_create_list_loop118:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop118:
cmp rdi, 0
je end_push_stack_loop118
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop118
end_push_stack_loop118:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body118

add_nil_to_stack118:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop118:
cmp rdi, 0
je end_add_nil_loop118
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop118
end_add_nil_loop118:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body118:
; ScmApplicTP': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
push rax
; ScmConst':
mov rax, const_tbl + 34
push rax
; ScmApplic': 
; ScmVar'(VarBound): _+
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): ^numeric-op-dispatcher
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure120
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure120:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 3
; ScmVar'(VarBound): fold-left
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure119
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure119:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop119:
cmp rsi, 64
je end_copy_stack_loop119
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop119
end_copy_stack_loop119:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont118:
mov qword [fvar_tbl + 24], rax
mov rax, SOB_VOID_ADDRESS
; ScmSet':
; VarFree: *
; ScmLambdaOpt': 
; Params: 
; Optional Param: x
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params121

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop121:
cmp rsi, 1
je end_copy_env_loop121
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop121
end_copy_env_loop121:

add_zero_rib_params121:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop121:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop121
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop121
end_copy_params_loop121:
MAKE_CLOSURE(rax, rdx, Lcode121)
jmp Lcont121
Lcode121:
push rbp
mov rbp , rsp
mov rbx, 0 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack121

adjust_stack_to_list121:
mov rsi, [rbp + 8 * 3]
sub rsi, 0
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 0
cmp rdx, 0
jne params_length_not_zero121
mov rdx, 1
jmp decided_param_count121
params_length_not_zero121:
mov rdx, rcx
sub rdx, 0
add rdx, 1
decided_param_count121:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop121:
cmp rdi, 0
je end_create_list_loop121
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop121
end_create_list_loop121:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop121:
cmp rdi, 0
je end_push_stack_loop121
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop121
end_push_stack_loop121:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body121

add_nil_to_stack121:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop121:
cmp rdi, 0
je end_add_nil_loop121
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop121
end_add_nil_loop121:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body121:
; ScmApplicTP': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
push rax
; ScmConst':
mov rax, const_tbl + 51
push rax
; ScmApplic': 
; ScmVar'(VarBound): _*
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 6]

push rax
push 1
; ScmVar'(VarBound): ^numeric-op-dispatcher
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure123
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure123:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 3
; ScmVar'(VarBound): fold-left
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure122
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure122:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop122:
cmp rsi, 64
je end_copy_stack_loop122
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop122
end_copy_stack_loop122:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont121:
mov qword [fvar_tbl + 16], rax
mov rax, SOB_VOID_ADDRESS
; ScmSet':
; VarFree: /
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): _/
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 7]

push rax
push 1
;ScmVar'(VarParam): ^numeric-op-dispatcher
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure131
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure131:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmLambdaSimple': 
; Params: /
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params125

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop125:
cmp rsi, 1
je end_copy_env_loop125
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop125
end_copy_env_loop125:

add_zero_rib_params125:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop125:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop125
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop125
end_copy_params_loop125:
MAKE_CLOSURE(rax, rdx, Lcode125)
jmp Lcont125
Lcode125:
push rbp
mov rbp , rsp
; ScmLambdaOpt': 
; Params: x
; Optional Param: y
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params126

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop126:
cmp rsi, 2
je end_copy_env_loop126
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop126
end_copy_env_loop126:

add_zero_rib_params126:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop126:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop126
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop126
end_copy_params_loop126:
MAKE_CLOSURE(rax, rdx, Lcode126)
jmp Lcont126
Lcode126:
push rbp
mov rbp , rsp
mov rbx, 1 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack126

adjust_stack_to_list126:
mov rsi, [rbp + 8 * 3]
sub rsi, 1
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 1
cmp rdx, 0
jne params_length_not_zero126
mov rdx, 1
jmp decided_param_count126
params_length_not_zero126:
mov rdx, rcx
sub rdx, 1
add rdx, 1
decided_param_count126:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop126:
cmp rdi, 0
je end_create_list_loop126
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop126
end_create_list_loop126:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop126:
cmp rdi, 0
je end_push_stack_loop126
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop126
end_push_stack_loop126:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body126

add_nil_to_stack126:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop126:
cmp rdi, 0
je end_add_nil_loop126
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop126
end_add_nil_loop126:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body126:
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 12]
cmp byte [rax], T_CLOSURE
je is_closure128
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure128:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse127
; ScmApplicTP': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
push rax
; ScmConst':
mov rax, const_tbl + 51

push rax
push 2
; ScmVar'(VarBound): /
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure129
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure129:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop129:
cmp rsi, 56
je end_copy_stack_loop129
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop129
end_copy_stack_loop129:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit127
Lelse127:
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
push rax
; ScmVar'(VarBound): /
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 3
; ScmVar'(VarBound): fold-left
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure130
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure130:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop130:
cmp rsi, 64
je end_copy_stack_loop130
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop130
end_copy_stack_loop130:
add rsp, rdi
pop rbp
jmp rax
Lexit127:
leave
ret
Lcont126:
leave
ret
Lcont125:
cmp byte [rax], T_CLOSURE
je is_closure124
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure124:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 40], rax
mov rax, SOB_VOID_ADDRESS
; ScmApplicTP': 
; ScmLambdaSimple': 
; Params: op
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params138

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop138:
cmp rsi, 1
je end_copy_env_loop138
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop138
end_copy_env_loop138:

add_zero_rib_params138:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop138:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop138
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop138
end_copy_params_loop138:
MAKE_CLOSURE(rax, rdx, Lcode138)
jmp Lcont138
Lcode138:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: comparator
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params140

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop140:
cmp rsi, 2
je end_copy_env_loop140
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop140
end_copy_env_loop140:

add_zero_rib_params140:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop140:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop140
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop140
end_copy_params_loop140:
MAKE_CLOSURE(rax, rdx, Lcode140)
jmp Lcont140
Lcode140:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: comparator
; ScmBox':
;ScmVar'(VarParam): comparator
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: x, ys
mov rdx, 5
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params141

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop141:
cmp rsi, 3
je end_copy_env_loop141
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop141
end_copy_env_loop141:

add_zero_rib_params141:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop141:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop141
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop141
end_copy_params_loop141:
MAKE_CLOSURE(rax, rdx, Lcode141)
jmp Lcont141
Lcode141:
push rbp
mov rbp , rsp
; ScmOr': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 12]
cmp byte [rax], T_CLOSURE
je is_closure143
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure143:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
jne Lexit142
; ScmIf': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 10]
cmp byte [rax], T_CLOSURE
je is_closure146
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure146:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): op
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure145
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure145:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse144
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 11]
cmp byte [rax], T_CLOSURE
je is_closure148
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure148:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 10]
cmp byte [rax], T_CLOSURE
je is_closure149
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure149:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): comparator
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure147
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure147:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop147:
cmp rsi, 56
je end_copy_stack_loop147
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop147
end_copy_stack_loop147:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit144
Lelse144:
; ScmConst':
mov rax, const_tbl + 2
Lexit144:
Lexit142:
leave
ret
Lcont141:
mov rbx, rax
;ScmVar'(VarParam): comparator
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmLambdaOpt': 
; Params: x
; Optional Param: y
mov rdx, 5
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params150

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop150:
cmp rsi, 3
je end_copy_env_loop150
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop150
end_copy_env_loop150:

add_zero_rib_params150:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop150:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop150
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop150
end_copy_params_loop150:
MAKE_CLOSURE(rax, rdx, Lcode150)
jmp Lcont150
Lcode150:
push rbp
mov rbp , rsp
mov rbx, 1 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack150

adjust_stack_to_list150:
mov rsi, [rbp + 8 * 3]
sub rsi, 1
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 1
cmp rdx, 0
jne params_length_not_zero150
mov rdx, 1
jmp decided_param_count150
params_length_not_zero150:
mov rdx, rcx
sub rdx, 1
add rdx, 1
decided_param_count150:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop150:
cmp rdi, 0
je end_create_list_loop150
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop150
end_create_list_loop150:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop150:
cmp rdi, 0
je end_push_stack_loop150
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop150
end_push_stack_loop150:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body150

add_nil_to_stack150:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop150:
cmp rdi, 0
je end_add_nil_loop150
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop150
end_add_nil_loop150:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body150:
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): comparator
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure151
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure151:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop151:
cmp rsi, 56
je end_copy_stack_loop151
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop151
end_copy_stack_loop151:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont150:
leave
ret
Lcont140:
cmp byte [rax], T_CLOSURE
je is_closure139
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure139:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop139:
cmp rsi, 48
je end_copy_stack_loop139
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop139
end_copy_stack_loop139:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont138:

push rax
push 1
; ScmLambdaSimple': 
; Params: ^comparator
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params133

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop133:
cmp rsi, 1
je end_copy_env_loop133
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop133
end_copy_env_loop133:

add_zero_rib_params133:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop133:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop133
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop133
end_copy_params_loop133:
MAKE_CLOSURE(rax, rdx, Lcode133)
jmp Lcont133
Lcode133:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarFree: =
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): _=
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 8]

push rax
push 1
; ScmVar'(VarBound): ^numeric-op-dispatcher
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure135
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure135:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
;ScmVar'(VarParam): ^comparator
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure134
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure134:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 56], rax
mov rax, SOB_VOID_ADDRESS
; ScmSet':
; VarFree: <
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): _<
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 9]

push rax
push 1
; ScmVar'(VarBound): ^numeric-op-dispatcher
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure137
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure137:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
;ScmVar'(VarParam): ^comparator
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure136
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure136:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 48], rax
mov rax, SOB_VOID_ADDRESS
leave
ret
Lcont133:
cmp byte [rax], T_CLOSURE
je is_closure132
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure132:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop132:
cmp rsi, 48
je end_copy_stack_loop132
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop132
end_copy_stack_loop132:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont117:
cmp byte [rax], T_CLOSURE
je is_closure116
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure116:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop116:
cmp rsi, 48
je end_copy_stack_loop116
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop116
end_copy_stack_loop116:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont115:
cmp byte [rax], T_CLOSURE
je is_closure114
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure114:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

	call write_sob_if_not_void

; ScmDef':
; VarFree: -
; ScmApplic': 
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]
push rax
; ScmVar'(VarFree): +
mov rax, qword [fvar_tbl + 24]
push rax
; ScmVar'(VarFree): apply
mov rax, qword [fvar_tbl + 80]

push rax
push 3
; ScmLambdaSimple': 
; Params: apply, +, null?
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params168

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop168:
cmp rsi, -1
je end_copy_env_loop168
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop168
end_copy_env_loop168:

add_zero_rib_params168:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop168:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop168
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop168
end_copy_params_loop168:
MAKE_CLOSURE(rax, rdx, Lcode168)
jmp Lcont168
Lcode168:
push rbp
mov rbp , rsp
; ScmLambdaOpt': 
; Params: x
; Optional Param: y
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params169

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop169:
cmp rsi, 0
je end_copy_env_loop169
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop169
end_copy_env_loop169:

add_zero_rib_params169:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop169:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop169
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop169
end_copy_params_loop169:
MAKE_CLOSURE(rax, rdx, Lcode169)
jmp Lcont169
Lcode169:
push rbp
mov rbp , rsp
mov rbx, 1 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack169

adjust_stack_to_list169:
mov rsi, [rbp + 8 * 3]
sub rsi, 1
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 1
cmp rdx, 0
jne params_length_not_zero169
mov rdx, 1
jmp decided_param_count169
params_length_not_zero169:
mov rdx, rcx
sub rdx, 1
add rdx, 1
decided_param_count169:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop169:
cmp rdi, 0
je end_create_list_loop169
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop169
end_create_list_loop169:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop169:
cmp rdi, 0
je end_push_stack_loop169
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop169
end_push_stack_loop169:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body169

add_nil_to_stack169:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop169:
cmp rdi, 0
je end_add_nil_loop169
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop169
end_add_nil_loop169:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body169:
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure171
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure171:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse170
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
push rax
; ScmConst':
mov rax, const_tbl + 68

push rax
push 2
; ScmVar'(VarFree): *
mov rax, qword [fvar_tbl + 16]
cmp byte [rax], T_CLOSURE
je is_closure173
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure173:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmConst':
mov rax, const_tbl + 34

push rax
push 2
; ScmVar'(VarBound): +
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure172
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure172:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop172:
cmp rsi, 56
je end_copy_stack_loop172
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop172
end_copy_stack_loop172:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit170
Lelse170:
; ScmApplicTP': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
; ScmVar'(VarBound): +
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

push rax
push 2
; ScmVar'(VarBound): apply
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure176
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure176:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmConst':
mov rax, const_tbl + 68

push rax
push 2
; ScmVar'(VarFree): *
mov rax, qword [fvar_tbl + 16]
cmp byte [rax], T_CLOSURE
je is_closure175
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure175:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): +
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure174
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure174:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop174:
cmp rsi, 56
je end_copy_stack_loop174
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop174
end_copy_stack_loop174:
add rsp, rdi
pop rbp
jmp rax
Lexit170:
leave
ret
Lcont169:
leave
ret
Lcont168:
cmp byte [rax], T_CLOSURE
je is_closure167
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure167:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 32], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: >
; ScmApplic': 
; ScmVar'(VarFree): =
mov rax, qword [fvar_tbl + 56]
push rax
; ScmVar'(VarFree): <
mov rax, qword [fvar_tbl + 48]
push rax
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): not
mov rax, qword [fvar_tbl + 264]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 6
; ScmLambdaSimple': 
; Params: null?, not, car, cdr, <, =
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params178

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop178:
cmp rsi, -1
je end_copy_env_loop178
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop178
end_copy_env_loop178:

add_zero_rib_params178:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop178:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop178
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop178
end_copy_params_loop178:
MAKE_CLOSURE(rax, rdx, Lcode178)
jmp Lcont178
Lcode178:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: >-loop
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params180

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop180:
cmp rsi, 0
je end_copy_env_loop180
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop180
end_copy_env_loop180:

add_zero_rib_params180:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop180:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop180
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop180
end_copy_params_loop180:
MAKE_CLOSURE(rax, rdx, Lcode180)
jmp Lcont180
Lcode180:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: >-loop
; ScmBox':
;ScmVar'(VarParam): >-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: x, ys
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params181

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop181:
cmp rsi, 1
je end_copy_env_loop181
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop181
end_copy_env_loop181:

add_zero_rib_params181:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop181:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop181
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop181
end_copy_params_loop181:
MAKE_CLOSURE(rax, rdx, Lcode181)
jmp Lcont181
Lcode181:
push rbp
mov rbp , rsp
; ScmOr': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure183
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure183:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
jne Lexit182
; ScmIf': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure187
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure187:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): <
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure186
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure186:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): not
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure185
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure185:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse184
; ScmIf': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure191
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure191:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): =
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]
cmp byte [rax], T_CLOSURE
je is_closure190
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure190:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): not
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure189
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure189:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse188
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure193
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure193:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure194
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure194:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): >-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure192
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure192:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop192:
cmp rsi, 56
je end_copy_stack_loop192
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop192
end_copy_stack_loop192:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit188
Lelse188:
; ScmConst':
mov rax, const_tbl + 2
Lexit188:
jmp Lexit184
Lelse184:
; ScmConst':
mov rax, const_tbl + 2
Lexit184:
Lexit182:
leave
ret
Lcont181:
mov rbx, rax
;ScmVar'(VarParam): >-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmLambdaOpt': 
; Params: x
; Optional Param: y
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params195

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop195:
cmp rsi, 1
je end_copy_env_loop195
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop195
end_copy_env_loop195:

add_zero_rib_params195:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop195:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop195
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop195
end_copy_params_loop195:
MAKE_CLOSURE(rax, rdx, Lcode195)
jmp Lcont195
Lcode195:
push rbp
mov rbp , rsp
mov rbx, 1 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack195

adjust_stack_to_list195:
mov rsi, [rbp + 8 * 3]
sub rsi, 1
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 1
cmp rdx, 0
jne params_length_not_zero195
mov rdx, 1
jmp decided_param_count195
params_length_not_zero195:
mov rdx, rcx
sub rdx, 1
add rdx, 1
decided_param_count195:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop195:
cmp rdi, 0
je end_create_list_loop195
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop195
end_create_list_loop195:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop195:
cmp rdi, 0
je end_push_stack_loop195
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop195
end_push_stack_loop195:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body195

add_nil_to_stack195:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop195:
cmp rdi, 0
je end_add_nil_loop195
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop195
end_add_nil_loop195:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body195:
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): >-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure196
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure196:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop196:
cmp rsi, 56
je end_copy_stack_loop196
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop196
end_copy_stack_loop196:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont195:
leave
ret
Lcont180:
cmp byte [rax], T_CLOSURE
je is_closure179
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure179:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop179:
cmp rsi, 48
je end_copy_stack_loop179
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop179
end_copy_stack_loop179:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont178:
cmp byte [rax], T_CLOSURE
je is_closure177
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure177:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 64], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: gcd
; ScmApplic': 
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]
push rax
; ScmVar'(VarFree): gcd
mov rax, qword [fvar_tbl + 200]

push rax
push 4
; ScmLambdaSimple': 
; Params: gcd, null?, car, cdr
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params198

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop198:
cmp rsi, -1
je end_copy_env_loop198
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop198
end_copy_env_loop198:

add_zero_rib_params198:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop198:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop198
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop198
end_copy_params_loop198:
MAKE_CLOSURE(rax, rdx, Lcode198)
jmp Lcont198
Lcode198:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: gcd-loop
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params200

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop200:
cmp rsi, 0
je end_copy_env_loop200
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop200
end_copy_env_loop200:

add_zero_rib_params200:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop200:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop200
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop200
end_copy_params_loop200:
MAKE_CLOSURE(rax, rdx, Lcode200)
jmp Lcont200
Lcode200:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: gcd-loop
; ScmBox':
;ScmVar'(VarParam): gcd-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: x, ys
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params201

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop201:
cmp rsi, 1
je end_copy_env_loop201
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop201
end_copy_env_loop201:

add_zero_rib_params201:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop201:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop201
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop201
end_copy_params_loop201:
MAKE_CLOSURE(rax, rdx, Lcode201)
jmp Lcont201
Lcode201:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure203
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure203:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse202
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
jmp Lexit202
Lelse202:
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure205
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure205:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure207
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure207:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): gcd
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure206
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure206:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): gcd-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure204
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure204:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop204:
cmp rsi, 56
je end_copy_stack_loop204
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop204
end_copy_stack_loop204:
add rsp, rdi
pop rbp
jmp rax
Lexit202:
leave
ret
Lcont201:
mov rbx, rax
;ScmVar'(VarParam): gcd-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmLambdaOpt': 
; Params: 
; Optional Param: x
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params208

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop208:
cmp rsi, 1
je end_copy_env_loop208
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop208
end_copy_env_loop208:

add_zero_rib_params208:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop208:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop208
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop208
end_copy_params_loop208:
MAKE_CLOSURE(rax, rdx, Lcode208)
jmp Lcont208
Lcode208:
push rbp
mov rbp , rsp
mov rbx, 0 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack208

adjust_stack_to_list208:
mov rsi, [rbp + 8 * 3]
sub rsi, 0
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 0
cmp rdx, 0
jne params_length_not_zero208
mov rdx, 1
jmp decided_param_count208
params_length_not_zero208:
mov rdx, rcx
sub rdx, 0
add rdx, 1
decided_param_count208:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop208:
cmp rdi, 0
je end_create_list_loop208
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop208
end_create_list_loop208:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop208:
cmp rdi, 0
je end_push_stack_loop208
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop208
end_push_stack_loop208:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body208

add_nil_to_stack208:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop208:
cmp rdi, 0
je end_add_nil_loop208
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop208
end_add_nil_loop208:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body208:
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure210
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure210:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse209
; ScmConst':
mov rax, const_tbl + 34
jmp Lexit209
Lelse209:
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure212
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure212:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure213
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure213:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): gcd-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure211
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure211:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop211:
cmp rsi, 56
je end_copy_stack_loop211
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop211
end_copy_stack_loop211:
add rsp, rdi
pop rbp
jmp rax
Lexit209:
leave
ret
Lcont208:
leave
ret
Lcont200:
cmp byte [rax], T_CLOSURE
je is_closure199
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure199:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop199:
cmp rsi, 48
je end_copy_stack_loop199
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop199
end_copy_stack_loop199:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont198:
cmp byte [rax], T_CLOSURE
je is_closure197
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure197:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 200], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: zero?
; ScmApplic': 
; ScmVar'(VarFree): =
mov rax, qword [fvar_tbl + 56]

push rax
push 1
; ScmLambdaSimple': 
; Params: =
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params215

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop215:
cmp rsi, -1
je end_copy_env_loop215
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop215
end_copy_env_loop215:

add_zero_rib_params215:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop215:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop215
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop215
end_copy_params_loop215:
MAKE_CLOSURE(rax, rdx, Lcode215)
jmp Lcont215
Lcode215:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: x
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params216

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop216:
cmp rsi, 0
je end_copy_env_loop216
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop216
end_copy_env_loop216:

add_zero_rib_params216:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop216:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop216
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop216
end_copy_params_loop216:
MAKE_CLOSURE(rax, rdx, Lcode216)
jmp Lcont216
Lcode216:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 34
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): =
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure217
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure217:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop217:
cmp rsi, 56
je end_copy_stack_loop217
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop217
end_copy_stack_loop217:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont216:
leave
ret
Lcont215:
cmp byte [rax], T_CLOSURE
je is_closure214
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure214:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 392], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: integer?
; ScmApplic': 
; ScmVar'(VarFree): denominator
mov rax, qword [fvar_tbl + 144]
push rax
; ScmVar'(VarFree): =
mov rax, qword [fvar_tbl + 56]
push rax
; ScmVar'(VarFree): rational?
mov rax, qword [fvar_tbl + 312]

push rax
push 3
; ScmLambdaSimple': 
; Params: rational?, =, denominator
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params219

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop219:
cmp rsi, -1
je end_copy_env_loop219
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop219
end_copy_env_loop219:

add_zero_rib_params219:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop219:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop219
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop219
end_copy_params_loop219:
MAKE_CLOSURE(rax, rdx, Lcode219)
jmp Lcont219
Lcode219:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: x
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params220

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop220:
cmp rsi, 0
je end_copy_env_loop220
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop220
end_copy_env_loop220:

add_zero_rib_params220:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop220:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop220
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop220
end_copy_params_loop220:
MAKE_CLOSURE(rax, rdx, Lcode220)
jmp Lcont220
Lcode220:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): rational?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure222
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure222:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse221
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 51
push rax
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): denominator
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure224
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure224:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarBound): =
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure223
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure223:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop223:
cmp rsi, 56
je end_copy_stack_loop223
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop223
end_copy_stack_loop223:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit221
Lelse221:
; ScmConst':
mov rax, const_tbl + 2
Lexit221:
leave
ret
Lcont220:
leave
ret
Lcont219:
cmp byte [rax], T_CLOSURE
je is_closure218
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure218:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 208], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: number?
; ScmApplic': 
; ScmVar'(VarFree): rational?
mov rax, qword [fvar_tbl + 312]
push rax
; ScmVar'(VarFree): flonum?
mov rax, qword [fvar_tbl + 176]

push rax
push 2
; ScmLambdaSimple': 
; Params: flonum?, rational?
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params226

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop226:
cmp rsi, -1
je end_copy_env_loop226
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop226
end_copy_env_loop226:

add_zero_rib_params226:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop226:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop226
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop226
end_copy_params_loop226:
MAKE_CLOSURE(rax, rdx, Lcode226)
jmp Lcont226
Lcode226:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: x
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params227

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop227:
cmp rsi, 0
je end_copy_env_loop227
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop227
end_copy_env_loop227:

add_zero_rib_params227:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop227:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop227
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop227
end_copy_params_loop227:
MAKE_CLOSURE(rax, rdx, Lcode227)
jmp Lcont227
Lcode227:
push rbp
mov rbp , rsp
; ScmOr': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): flonum?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure229
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure229:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
jne Lexit228
; ScmApplicTP': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): rational?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure230
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure230:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop230:
cmp rsi, 48
je end_copy_stack_loop230
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop230
end_copy_stack_loop230:
add rsp, rdi
pop rbp
jmp rax
Lexit228:
leave
ret
Lcont227:
leave
ret
Lcont226:
cmp byte [rax], T_CLOSURE
je is_closure225
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure225:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 280], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: length
; ScmApplic': 
; ScmVar'(VarFree): +
mov rax, qword [fvar_tbl + 24]
push rax
; ScmVar'(VarFree): fold-left
mov rax, qword [fvar_tbl + 184]

push rax
push 2
; ScmLambdaSimple': 
; Params: fold-left, +
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params232

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop232:
cmp rsi, -1
je end_copy_env_loop232
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop232
end_copy_env_loop232:

add_zero_rib_params232:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop232:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop232
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop232
end_copy_params_loop232:
MAKE_CLOSURE(rax, rdx, Lcode232)
jmp Lcont232
Lcode232:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: l
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params233

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop233:
cmp rsi, 0
je end_copy_env_loop233
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop233
end_copy_env_loop233:

add_zero_rib_params233:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop233:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop233
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop233
end_copy_params_loop233:
MAKE_CLOSURE(rax, rdx, Lcode233)
jmp Lcont233
Lcode233:
push rbp
mov rbp , rsp
; ScmApplicTP': 
;ScmVar'(VarParam): l
mov rax, qword [rbp + 8 * 4]
push rax
; ScmConst':
mov rax, const_tbl + 34
push rax
; ScmLambdaSimple': 
; Params: acc, e
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params235

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop235:
cmp rsi, 1
je end_copy_env_loop235
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop235
end_copy_env_loop235:

add_zero_rib_params235:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop235:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop235
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop235
end_copy_params_loop235:
MAKE_CLOSURE(rax, rdx, Lcode235)
jmp Lcont235
Lcode235:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 51
push rax
;ScmVar'(VarParam): acc
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): +
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure236
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure236:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop236:
cmp rsi, 56
je end_copy_stack_loop236
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop236
end_copy_stack_loop236:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont235:

push rax
push 3
; ScmVar'(VarBound): fold-left
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure234
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure234:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop234:
cmp rsi, 64
je end_copy_stack_loop234
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop234
end_copy_stack_loop234:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont233:
leave
ret
Lcont232:
cmp byte [rax], T_CLOSURE
je is_closure231
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure231:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 224], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: string->list
; ScmApplic': 
; ScmVar'(VarFree): cons
mov rax, qword [fvar_tbl + 128]
push rax
; ScmVar'(VarFree): -
mov rax, qword [fvar_tbl + 32]
push rax
; ScmVar'(VarFree): <
mov rax, qword [fvar_tbl + 48]
push rax
; ScmVar'(VarFree): string-length
mov rax, qword [fvar_tbl + 344]
push rax
; ScmVar'(VarFree): string-ref
mov rax, qword [fvar_tbl + 352]

push rax
push 5
; ScmLambdaSimple': 
; Params: string-ref, string-length, <, -, cons
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params238

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop238:
cmp rsi, -1
je end_copy_env_loop238
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop238
end_copy_env_loop238:

add_zero_rib_params238:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop238:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop238
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop238
end_copy_params_loop238:
MAKE_CLOSURE(rax, rdx, Lcode238)
jmp Lcont238
Lcode238:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: s
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params239

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop239:
cmp rsi, 0
je end_copy_env_loop239
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop239
end_copy_env_loop239:

add_zero_rib_params239:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop239:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop239
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop239
end_copy_params_loop239:
MAKE_CLOSURE(rax, rdx, Lcode239)
jmp Lcont239
Lcode239:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: s->l-loop
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params241

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop241:
cmp rsi, 1
je end_copy_env_loop241
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop241
end_copy_env_loop241:

add_zero_rib_params241:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop241:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop241
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop241
end_copy_params_loop241:
MAKE_CLOSURE(rax, rdx, Lcode241)
jmp Lcont241
Lcode241:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: s->l-loop
; ScmBox':
;ScmVar'(VarParam): s->l-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: n, a
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params242

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop242:
cmp rsi, 2
je end_copy_env_loop242
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop242
end_copy_env_loop242:

add_zero_rib_params242:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop242:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop242
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop242
end_copy_params_loop242:
MAKE_CLOSURE(rax, rdx, Lcode242)
jmp Lcont242
Lcode242:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
; ScmConst':
mov rax, const_tbl + 34
push rax
;ScmVar'(VarParam): n
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): <
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure244
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure244:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse243
;ScmVar'(VarParam): a
mov rax, qword [rbp + 8 * 5]
jmp Lexit243
Lelse243:
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): a
mov rax, qword [rbp + 8 * 5]
push rax
; ScmApplic': 
;ScmVar'(VarParam): n
mov rax, qword [rbp + 8 * 4]
push rax
; ScmVar'(VarBound): s
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]

push rax
push 2
; ScmVar'(VarBound): string-ref
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure247
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure247:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarBound): cons
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure246
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure246:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
; ScmConst':
mov rax, const_tbl + 51
push rax
;ScmVar'(VarParam): n
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): -
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure248
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure248:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): s->l-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure245
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure245:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop245:
cmp rsi, 56
je end_copy_stack_loop245
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop245
end_copy_stack_loop245:
add rsp, rdi
pop rbp
jmp rax
Lexit243:
leave
ret
Lcont242:
mov rbx, rax
;ScmVar'(VarParam): s->l-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 1
push rax
; ScmApplic': 
; ScmConst':
mov rax, const_tbl + 51
push rax
; ScmApplic': 
; ScmVar'(VarBound): s
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): string-length
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure251
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure251:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarBound): -
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure250
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure250:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
;ScmVar'(VarParam): s->l-loop
mov rax, qword [rbp + 8 * 4]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure249
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure249:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop249:
cmp rsi, 56
je end_copy_stack_loop249
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop249
end_copy_stack_loop249:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont241:
cmp byte [rax], T_CLOSURE
je is_closure240
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure240:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop240:
cmp rsi, 48
je end_copy_stack_loop240
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop240
end_copy_stack_loop240:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont239:
leave
ret
Lcont238:
cmp byte [rax], T_CLOSURE
je is_closure237
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure237:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 336], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: equal?
; ScmApplic': 
; ScmVar'(VarFree): char->integer
mov rax, qword [fvar_tbl + 112]
push rax
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): eq?
mov rax, qword [fvar_tbl + 152]
push rax
; ScmVar'(VarFree): string?
mov rax, qword [fvar_tbl + 368]
push rax
; ScmVar'(VarFree): char?
mov rax, qword [fvar_tbl + 120]
push rax
; ScmVar'(VarFree): pair?
mov rax, qword [fvar_tbl + 296]
push rax
; ScmVar'(VarFree): flonum?
mov rax, qword [fvar_tbl + 176]
push rax
; ScmVar'(VarFree): rational?
mov rax, qword [fvar_tbl + 312]
push rax
; ScmVar'(VarFree): string->list
mov rax, qword [fvar_tbl + 336]
push rax
; ScmVar'(VarFree): =
mov rax, qword [fvar_tbl + 56]

push rax
push 11
; ScmLambdaSimple': 
; Params: =, string->list, rational?, flonum?, pair?, char?, string?, eq?, car, cdr, char->integer
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params253

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop253:
cmp rsi, -1
je end_copy_env_loop253
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop253
end_copy_env_loop253:

add_zero_rib_params253:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop253:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop253
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop253
end_copy_params_loop253:
MAKE_CLOSURE(rax, rdx, Lcode253)
jmp Lcont253
Lcode253:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: equal?-loop
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params255

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop255:
cmp rsi, 0
je end_copy_env_loop255
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop255
end_copy_env_loop255:

add_zero_rib_params255:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop255:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop255
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop255
end_copy_params_loop255:
MAKE_CLOSURE(rax, rdx, Lcode255)
jmp Lcont255
Lcode255:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: equal?-loop
; ScmBox':
;ScmVar'(VarParam): equal?-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: x, y
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params256

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop256:
cmp rsi, 1
je end_copy_env_loop256
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop256
end_copy_env_loop256:

add_zero_rib_params256:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop256:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop256
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop256
end_copy_params_loop256:
MAKE_CLOSURE(rax, rdx, Lcode256)
jmp Lcont256
Lcode256:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): rational?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure259
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure259:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse258
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): rational?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure260
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure260:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
jmp Lexit258
Lelse258:
; ScmConst':
mov rax, const_tbl + 2
Lexit258:
cmp rax, SOB_FALSE_ADDRESS
je Lelse257
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): =
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure261
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure261:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop261:
cmp rsi, 56
je end_copy_stack_loop261
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop261
end_copy_stack_loop261:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit257
Lelse257:
; ScmIf': 
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): flonum?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure264
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure264:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse263
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): flonum?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure265
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure265:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
jmp Lexit263
Lelse263:
; ScmConst':
mov rax, const_tbl + 2
Lexit263:
cmp rax, SOB_FALSE_ADDRESS
je Lelse262
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): =
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure266
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure266:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop266:
cmp rsi, 56
je end_copy_stack_loop266
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop266
end_copy_stack_loop266:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit262
Lelse262:
; ScmIf': 
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): char?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]
cmp byte [rax], T_CLOSURE
je is_closure269
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure269:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse268
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): char?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]
cmp byte [rax], T_CLOSURE
je is_closure270
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure270:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
jmp Lexit268
Lelse268:
; ScmConst':
mov rax, const_tbl + 2
Lexit268:
cmp rax, SOB_FALSE_ADDRESS
je Lelse267
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): char->integer
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 10]
cmp byte [rax], T_CLOSURE
je is_closure272
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure272:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): char->integer
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 10]
cmp byte [rax], T_CLOSURE
je is_closure273
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure273:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarBound): =
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure271
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure271:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop271:
cmp rsi, 56
je end_copy_stack_loop271
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop271
end_copy_stack_loop271:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit267
Lelse267:
; ScmIf': 
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): pair?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure276
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure276:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse275
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): pair?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure277
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure277:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
jmp Lexit275
Lelse275:
; ScmConst':
mov rax, const_tbl + 2
Lexit275:
cmp rax, SOB_FALSE_ADDRESS
je Lelse274
; ScmIf': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 8]
cmp byte [rax], T_CLOSURE
je is_closure280
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure280:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 8]
cmp byte [rax], T_CLOSURE
je is_closure281
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure281:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): equal?-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure279
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure279:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse278
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 9]
cmp byte [rax], T_CLOSURE
je is_closure283
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure283:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 9]
cmp byte [rax], T_CLOSURE
je is_closure284
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure284:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): equal?-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure282
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure282:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop282:
cmp rsi, 56
je end_copy_stack_loop282
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop282
end_copy_stack_loop282:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit278
Lelse278:
; ScmConst':
mov rax, const_tbl + 2
Lexit278:
jmp Lexit274
Lelse274:
; ScmIf': 
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): string?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 6]
cmp byte [rax], T_CLOSURE
je is_closure287
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure287:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse286
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): string?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 6]
cmp byte [rax], T_CLOSURE
je is_closure288
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure288:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
jmp Lexit286
Lelse286:
; ScmConst':
mov rax, const_tbl + 2
Lexit286:
cmp rax, SOB_FALSE_ADDRESS
je Lelse285
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): string->list
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure290
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure290:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): string->list
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure291
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure291:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): equal?-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure289
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure289:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop289:
cmp rsi, 56
je end_copy_stack_loop289
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop289
end_copy_stack_loop289:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit285
Lelse285:
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): eq?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 7]
cmp byte [rax], T_CLOSURE
je is_closure292
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure292:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop292:
cmp rsi, 56
je end_copy_stack_loop292
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop292
end_copy_stack_loop292:
add rsp, rdi
pop rbp
jmp rax
Lexit285:
Lexit274:
Lexit267:
Lexit262:
Lexit257:
leave
ret
Lcont256:
mov rbx, rax
;ScmVar'(VarParam): equal?-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmBoxGet':
;ScmVar'(VarParam): equal?-loop
mov rax, qword [rbp + 8 * 4]
CAR rax, rax
leave
ret
Lcont255:
cmp byte [rax], T_CLOSURE
je is_closure254
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure254:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop254:
cmp rsi, 48
je end_copy_stack_loop254
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop254
end_copy_stack_loop254:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont253:
cmp byte [rax], T_CLOSURE
je is_closure252
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure252:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 160], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmApplic': 
; ScmConst':
mov rax, const_tbl + 85
push rax
; ScmApplic': 
; ScmConst':
mov rax, const_tbl + 85
push rax
; ScmConst':
mov rax, const_tbl + 51
push rax
; ScmVar'(VarFree): +
mov rax, qword [fvar_tbl + 24]

push rax
push 3
; ScmVar'(VarFree): apply
mov rax, qword [fvar_tbl + 80]
cmp byte [rax], T_CLOSURE
je is_closure294
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure294:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmVar'(VarFree): +
mov rax, qword [fvar_tbl + 24]

push rax
push 3
; ScmVar'(VarFree): apply
mov rax, qword [fvar_tbl + 80]
cmp byte [rax], T_CLOSURE
je is_closure293
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure293:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

	call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 cmpltpd xmm0, xmm1
         movq rsi, xmm0
         cmp rsi, 0
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
         .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	 mov rdx, rax
         cmp rdx, 0
         jge .make_result
         neg rdx
         .make_result:
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret

car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CAR rax, rsi
         pop rbp
         ret

cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CDR rax, rsi
         pop rbp
         ret

cons:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	MAKE_PAIR(rax, rsi, rdi)
         pop rbp
         ret

set_car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov qword [rsi + 8 * 1], rdi
mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

set_cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov qword [rsi + 8 * 2], rdi
mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

apply:
       push rbp
       mov rbp, rsp 
       ; This code is basically the applicTP code
mov rbx, [rbp + 8 * 3] ; number of args on stack
add rbx, 3 ; rbx has the offset of the last argument
shl rbx, 3
add rbx, rsp ; this should point to the list at the end
mov rsi, 0 ; counter of how many args are pushed
cmp qword [rbx], SOB_NIL_ADDRESS
je end_reverse_stack_loop
mov rdx, qword [rbx]
push_the_list_loop:
CAR rax, rdx
push rax ; push car to reverse later
inc rsi
CDR rbx, rdx ; now rbx has the cdr of the list
mov rdx, rbx
cmp qword rbx, SOB_NIL_ADDRESS
jne push_the_list_loop
end_push_the_list_loop:
mov rbx, rbp
sub rbx, 8 * 1 ; copy from
mov rcx, rbp
shl rsi, 3
sub rcx, rsi ; copy to
shr rsi, 3
reverse_stack_loop:
cmp rbx, rcx
jle end_reverse_stack_loop
mov rdx, qword [rbx]
mov rax, qword [rcx]
mov qword [rcx], rdx
mov qword [rbx], rax
sub rbx, 8 * 1
add rcx, 8 * 1
jmp reverse_stack_loop
end_reverse_stack_loop:
mov rdi, [rbp + 8 * 3] ; number of args on stack
sub rdi, 2 ; 1 for list, 1 for proc
cmp rdi, 0
je end_push_stack_args_loop ; no other args to push
add rsi, rdi ; now rsi has all elements on stack
mov rbx, 4
add rbx, rdi
shl rbx, 3
add rbx, rbp ; this should point to the last arg (one before the list)
push_stack_args_loop:
cmp rdi, 0
je end_push_stack_args_loop
mov rax, qword [rbx]
push rax
sub rbx, 8 * 1
dec rdi
jmp push_stack_args_loop
end_push_stack_args_loop:
; now all args should be on the stack
push rsi ; number of args
mov r8, rsi ; have to use general purpose register to hold number of args
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
apply_copy_stack_loop:
shl r8, 3
add r8, 8 * 5
cmp rsi, r8
je end_apply_copy_stack_loop
sub r8, 8 * 5
shr r8, 3
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp apply_copy_stack_loop
end_apply_copy_stack_loop:
add rsp, rdi
pop rbp
jmp rax

         pop rbp
         ret