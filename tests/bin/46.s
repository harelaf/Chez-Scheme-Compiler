;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 51

section .data
const_tbl:
db T_VOID
db T_NIL
db T_BOOL, 0
db T_BOOL, 1
MAKE_LITERAL_STRING "whatever"
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_CHAR(0)
MAKE_LITERAL_RATIONAL(0,1)
MAKE_LITERAL_RATIONAL(1,1)
MAKE_LITERAL_RATIONAL(-1,1)
MAKE_LITERAL_RATIONAL(5,1)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+88], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+176], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+312], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+296], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+272], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+120], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+368], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+304], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+376], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+344], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+352], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+360], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+248], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+384], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+112], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+216], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+168], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+152], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+24], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+16], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+40], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+56], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+48], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+288], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+144], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+200], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov [fvar_tbl+80], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+96], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+104], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+128], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
mov [fvar_tbl+320], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
mov [fvar_tbl+328], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
; ScmDef':
; VarFree: map
; ScmApplic': 
; ScmVar'(VarFree): apply
mov rax, qword [fvar_tbl + 80]
push rax
; ScmVar'(VarFree): cons
mov rax, qword [fvar_tbl + 128]
push rax
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 5
; ScmLambdaSimple': 
; Params: null?, car, cdr, cons, apply
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1:
cmp rsi, -1
je end_copy_env_loop1
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1
end_copy_env_loop1:

add_zero_rib_params1:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1
end_copy_params_loop1:
MAKE_CLOSURE(rax, rdx, Lcode1)
jmp Lcont1
Lcode1:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23
push rax
; ScmConst':
mov rax, const_tbl + 23

push rax
push 2
; ScmLambdaSimple': 
; Params: map-many, map-one
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params3

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop3:
cmp rsi, 0
je end_copy_env_loop3
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop3
end_copy_env_loop3:

add_zero_rib_params3:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop3:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop3
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop3
end_copy_params_loop3:
MAKE_CLOSURE(rax, rdx, Lcode3)
jmp Lcont3
Lcode3:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: map-many
; ScmBox':
;ScmVar'(VarParam): map-many
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmSet':
; VarParam: map-one
; ScmBox':
;ScmVar'(VarParam): map-one
mov rax, qword [rbp + 8 * 5]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 40], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: f, lists
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params4

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop4:
cmp rsi, 1
je end_copy_env_loop4
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop4
end_copy_env_loop4:

add_zero_rib_params4:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop4:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop4
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop4
end_copy_params_loop4:
MAKE_CLOSURE(rax, rdx, Lcode4)
jmp Lcont4
Lcode4:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lists
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure7
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure7:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure6
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure6:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse5
; ScmConst':
mov rax, const_tbl + 1
jmp Lexit5
Lelse5:
; ScmApplicTP': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lists
mov rax, qword [rbp + 8 * 5]
push rax
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): map-one
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure10
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure10:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): f
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): map-many
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure9
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure9:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lists
mov rax, qword [rbp + 8 * 5]
push rax
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): map-one
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure12
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure12:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): f
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): apply
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure11
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure11:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarBound): cons
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure8
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure8:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop8:
cmp rsi, 56
je end_copy_stack_loop8
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop8
end_copy_stack_loop8:
add rsp, rdi
pop rbp
jmp rax
Lexit5:
leave
ret
Lcont4:
mov rbx, rax
;ScmVar'(VarParam): map-many
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: f, s
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params13

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop13:
cmp rsi, 1
je end_copy_env_loop13
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop13
end_copy_env_loop13:

add_zero_rib_params13:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop13:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop13
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop13
end_copy_params_loop13:
MAKE_CLOSURE(rax, rdx, Lcode13)
jmp Lcont13
Lcode13:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): s
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure15
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure15:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse14
; ScmConst':
mov rax, const_tbl + 1
jmp Lexit14
Lelse14:
; ScmApplicTP': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): s
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure18
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure18:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): f
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): map-one
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure17
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure17:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): s
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure20
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure20:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
;ScmVar'(VarParam): f
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure19
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure19:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarBound): cons
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure16
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure16:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop16:
cmp rsi, 56
je end_copy_stack_loop16
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop16
end_copy_stack_loop16:
add rsp, rdi
pop rbp
jmp rax
Lexit14:
leave
ret
Lcont13:
mov rbx, rax
;ScmVar'(VarParam): map-one
mov rax, qword [rbp + 8 * 5]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmLambdaOpt': 
; Params: f
; Optional Param: args
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params21

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop21:
cmp rsi, 1
je end_copy_env_loop21
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop21
end_copy_env_loop21:

add_zero_rib_params21:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop21:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop21
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop21
end_copy_params_loop21:
MAKE_CLOSURE(rax, rdx, Lcode21)
jmp Lcont21
Lcode21:
push rbp
mov rbp , rsp
mov rbx, 1 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack21

adjust_stack_to_list21:
mov rsi, [rbp + 8 * 3]
sub rsi, 1
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 1
cmp rdx, 0
jne params_length_not_zero21
mov rdx, 1
jmp decided_param_count21
params_length_not_zero21:
mov rdx, rcx
sub rdx, 1
add rdx, 1
decided_param_count21:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop21:
cmp rdi, 0
je end_create_list_loop21
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop21
end_create_list_loop21:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop21:
cmp rdi, 0
je end_push_stack_loop21
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop21
end_push_stack_loop21:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body21

add_nil_to_stack21:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop21:
cmp rdi, 0
je end_add_nil_loop21
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop21
end_add_nil_loop21:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body21:
; ScmApplicTP': 
;ScmVar'(VarParam): args
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): f
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): map-many
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure22
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure22:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop22:
cmp rsi, 56
je end_copy_stack_loop22
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop22
end_copy_stack_loop22:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont21:
leave
ret
Lcont3:
cmp byte [rax], T_CLOSURE
je is_closure2
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure2:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop2:
cmp rsi, 56
je end_copy_stack_loop2
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop2
end_copy_stack_loop2:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont1:
cmp byte [rax], T_CLOSURE
je is_closure0
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure0:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 256], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: fold-left
; ScmApplic': 
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 3
; ScmLambdaSimple': 
; Params: null?, car, cdr
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params24

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop24:
cmp rsi, -1
je end_copy_env_loop24
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop24
end_copy_env_loop24:

add_zero_rib_params24:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop24:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop24
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop24
end_copy_params_loop24:
MAKE_CLOSURE(rax, rdx, Lcode24)
jmp Lcont24
Lcode24:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: proc, init, lst
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params25

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop25:
cmp rsi, 0
je end_copy_env_loop25
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop25
end_copy_env_loop25:

add_zero_rib_params25:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop25:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop25
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop25
end_copy_params_loop25:
MAKE_CLOSURE(rax, rdx, Lcode25)
jmp Lcont25
Lcode25:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: fold-left-loop
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params27

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop27:
cmp rsi, 1
je end_copy_env_loop27
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop27
end_copy_env_loop27:

add_zero_rib_params27:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop27:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop27
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop27
end_copy_params_loop27:
MAKE_CLOSURE(rax, rdx, Lcode27)
jmp Lcont27
Lcode27:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: fold-left-loop
; ScmBox':
;ScmVar'(VarParam): fold-left-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: proc, init, lst
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params28

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop28:
cmp rsi, 2
je end_copy_env_loop28
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop28
end_copy_env_loop28:

add_zero_rib_params28:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop28:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop28
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop28
end_copy_params_loop28:
MAKE_CLOSURE(rax, rdx, Lcode28)
jmp Lcont28
Lcode28:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 6]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure30
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure30:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse29
;ScmVar'(VarParam): init
mov rax, qword [rbp + 8 * 5]
jmp Lexit29
Lelse29:
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 6]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure32
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure32:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 6]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure34
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure34:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): init
mov rax, qword [rbp + 8 * 5]

push rax
push 2
;ScmVar'(VarParam): proc
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure33
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure33:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): proc
mov rax, qword [rbp + 8 * 4]

push rax
push 3
; ScmBoxGet':
; ScmVar'(VarBound): fold-left-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure31
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure31:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop31:
cmp rsi, 64
je end_copy_stack_loop31
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop31
end_copy_stack_loop31:
add rsp, rdi
pop rbp
jmp rax
Lexit29:
leave
ret
Lcont28:
mov rbx, rax
;ScmVar'(VarParam): fold-left-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmApplicTP': 
; ScmVar'(VarBound): lst
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
push rax
; ScmVar'(VarBound): init
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
push rax
; ScmVar'(VarBound): proc
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 3
; ScmBoxGet':
;ScmVar'(VarParam): fold-left-loop
mov rax, qword [rbp + 8 * 4]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure35
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure35:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop35:
cmp rsi, 64
je end_copy_stack_loop35
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop35
end_copy_stack_loop35:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont27:
cmp byte [rax], T_CLOSURE
je is_closure26
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure26:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop26:
cmp rsi, 48
je end_copy_stack_loop26
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop26
end_copy_stack_loop26:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont25:
leave
ret
Lcont24:
cmp byte [rax], T_CLOSURE
je is_closure23
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure23:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 184], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: fold-right
; ScmApplic': 
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 3
; ScmLambdaSimple': 
; Params: null?, car, cdr
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params37

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop37:
cmp rsi, -1
je end_copy_env_loop37
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop37
end_copy_env_loop37:

add_zero_rib_params37:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop37:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop37
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop37
end_copy_params_loop37:
MAKE_CLOSURE(rax, rdx, Lcode37)
jmp Lcont37
Lcode37:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: proc, init, lst
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params38

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop38:
cmp rsi, 0
je end_copy_env_loop38
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop38
end_copy_env_loop38:

add_zero_rib_params38:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop38:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop38
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop38
end_copy_params_loop38:
MAKE_CLOSURE(rax, rdx, Lcode38)
jmp Lcont38
Lcode38:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: fold-right-loop
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params40

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop40:
cmp rsi, 1
je end_copy_env_loop40
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop40
end_copy_env_loop40:

add_zero_rib_params40:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop40:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop40
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop40
end_copy_params_loop40:
MAKE_CLOSURE(rax, rdx, Lcode40)
jmp Lcont40
Lcode40:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: fold-right-loop
; ScmBox':
;ScmVar'(VarParam): fold-right-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: proc, init, lst
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params41

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop41:
cmp rsi, 2
je end_copy_env_loop41
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop41
end_copy_env_loop41:

add_zero_rib_params41:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop41:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop41
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop41
end_copy_params_loop41:
MAKE_CLOSURE(rax, rdx, Lcode41)
jmp Lcont41
Lcode41:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 6]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure43
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure43:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse42
;ScmVar'(VarParam): init
mov rax, qword [rbp + 8 * 5]
jmp Lexit42
Lelse42:
; ScmApplicTP': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 6]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure46
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure46:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): init
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): proc
mov rax, qword [rbp + 8 * 4]

push rax
push 3
; ScmBoxGet':
; ScmVar'(VarBound): fold-right-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure45
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure45:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 6]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure47
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure47:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
;ScmVar'(VarParam): proc
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure44
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure44:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop44:
cmp rsi, 56
je end_copy_stack_loop44
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop44
end_copy_stack_loop44:
add rsp, rdi
pop rbp
jmp rax
Lexit42:
leave
ret
Lcont41:
mov rbx, rax
;ScmVar'(VarParam): fold-right-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmApplicTP': 
; ScmVar'(VarBound): lst
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
push rax
; ScmVar'(VarBound): init
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
push rax
; ScmVar'(VarBound): proc
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 3
; ScmBoxGet':
;ScmVar'(VarParam): fold-right-loop
mov rax, qword [rbp + 8 * 4]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure48
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure48:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop48:
cmp rsi, 64
je end_copy_stack_loop48
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop48
end_copy_stack_loop48:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont40:
cmp byte [rax], T_CLOSURE
je is_closure39
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure39:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop39:
cmp rsi, 48
je end_copy_stack_loop39
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop39
end_copy_stack_loop39:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont38:
leave
ret
Lcont37:
cmp byte [rax], T_CLOSURE
je is_closure36
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure36:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 192], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: without-last-elem
; ScmApplic': 
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 3
; ScmLambdaSimple': 
; Params: null?, car, cdr
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params50

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop50:
cmp rsi, -1
je end_copy_env_loop50
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop50
end_copy_env_loop50:

add_zero_rib_params50:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop50:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop50
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop50
end_copy_params_loop50:
MAKE_CLOSURE(rax, rdx, Lcode50)
jmp Lcont50
Lcode50:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: lst
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params51

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop51:
cmp rsi, 0
je end_copy_env_loop51
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop51
end_copy_env_loop51:

add_zero_rib_params51:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop51:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop51
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop51
end_copy_params_loop51:
MAKE_CLOSURE(rax, rdx, Lcode51)
jmp Lcont51
Lcode51:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: without-last-elem-loop
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params53

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop53:
cmp rsi, 1
je end_copy_env_loop53
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop53
end_copy_env_loop53:

add_zero_rib_params53:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop53:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop53
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop53
end_copy_params_loop53:
MAKE_CLOSURE(rax, rdx, Lcode53)
jmp Lcont53
Lcode53:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: without-last-elem-loop
; ScmBox':
;ScmVar'(VarParam): without-last-elem-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: lst
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params54

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop54:
cmp rsi, 2
je end_copy_env_loop54
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop54
end_copy_env_loop54:

add_zero_rib_params54:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop54:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop54
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop54
end_copy_params_loop54:
MAKE_CLOSURE(rax, rdx, Lcode54)
jmp Lcont54
Lcode54:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure57
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure57:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure56
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure56:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse55
; ScmConst':
mov rax, const_tbl + 1
jmp Lexit55
Lelse55:
; ScmApplicTP': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure60
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure60:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmBoxGet':
; ScmVar'(VarBound): without-last-elem-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure59
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure59:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure61
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure61:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarFree): cons
mov rax, qword [fvar_tbl + 128]
cmp byte [rax], T_CLOSURE
je is_closure58
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure58:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop58:
cmp rsi, 56
je end_copy_stack_loop58
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop58
end_copy_stack_loop58:
add rsp, rdi
pop rbp
jmp rax
Lexit55:
leave
ret
Lcont54:
mov rbx, rax
;ScmVar'(VarParam): without-last-elem-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmApplicTP': 
; ScmVar'(VarBound): lst
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmBoxGet':
;ScmVar'(VarParam): without-last-elem-loop
mov rax, qword [rbp + 8 * 4]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure62
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure62:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop62:
cmp rsi, 48
je end_copy_stack_loop62
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop62
end_copy_stack_loop62:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont53:
cmp byte [rax], T_CLOSURE
je is_closure52
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure52:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop52:
cmp rsi, 48
je end_copy_stack_loop52
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop52
end_copy_stack_loop52:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont51:
leave
ret
Lcont50:
cmp byte [rax], T_CLOSURE
je is_closure49
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure49:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 0], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: last-elem
; ScmApplic': 
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 3
; ScmLambdaSimple': 
; Params: null?, car, cdr
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params64

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop64:
cmp rsi, -1
je end_copy_env_loop64
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop64
end_copy_env_loop64:

add_zero_rib_params64:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop64:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop64
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop64
end_copy_params_loop64:
MAKE_CLOSURE(rax, rdx, Lcode64)
jmp Lcont64
Lcode64:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: lst
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params65

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop65:
cmp rsi, 0
je end_copy_env_loop65
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop65
end_copy_env_loop65:

add_zero_rib_params65:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop65:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop65
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop65
end_copy_params_loop65:
MAKE_CLOSURE(rax, rdx, Lcode65)
jmp Lcont65
Lcode65:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: last-elem-loop
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params67

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop67:
cmp rsi, 1
je end_copy_env_loop67
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop67
end_copy_env_loop67:

add_zero_rib_params67:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop67:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop67
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop67
end_copy_params_loop67:
MAKE_CLOSURE(rax, rdx, Lcode67)
jmp Lcont67
Lcode67:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: last-elem-loop
; ScmBox':
;ScmVar'(VarParam): last-elem-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: lst
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params68

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop68:
cmp rsi, 2
je end_copy_env_loop68
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop68
end_copy_env_loop68:

add_zero_rib_params68:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop68:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop68
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop68
end_copy_params_loop68:
MAKE_CLOSURE(rax, rdx, Lcode68)
jmp Lcont68
Lcode68:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure71
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure71:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure70
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure70:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse69
; ScmApplicTP': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure72
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure72:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop72:
cmp rsi, 48
je end_copy_stack_loop72
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop72
end_copy_stack_loop72:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit69
Lelse69:
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): lst
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure74
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure74:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmBoxGet':
; ScmVar'(VarBound): last-elem-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure73
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure73:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop73:
cmp rsi, 48
je end_copy_stack_loop73
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop73
end_copy_stack_loop73:
add rsp, rdi
pop rbp
jmp rax
Lexit69:
leave
ret
Lcont68:
mov rbx, rax
;ScmVar'(VarParam): last-elem-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmApplicTP': 
; ScmVar'(VarBound): lst
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmBoxGet':
;ScmVar'(VarParam): last-elem-loop
mov rax, qword [rbp + 8 * 4]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure75
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure75:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop75:
cmp rsi, 48
je end_copy_stack_loop75
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop75
end_copy_stack_loop75:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont67:
cmp byte [rax], T_CLOSURE
je is_closure66
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure66:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop66:
cmp rsi, 48
je end_copy_stack_loop66
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop66
end_copy_stack_loop66:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont65:
leave
ret
Lcont64:
cmp byte [rax], T_CLOSURE
je is_closure63
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure63:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 8], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: cons*
; ScmApplic': 
; ScmVar'(VarFree): fold-right
mov rax, qword [fvar_tbl + 192]
push rax
; ScmVar'(VarFree): without-last-elem
mov rax, qword [fvar_tbl + 0]
push rax
; ScmVar'(VarFree): last-elem
mov rax, qword [fvar_tbl + 8]
push rax
; ScmVar'(VarFree): cons
mov rax, qword [fvar_tbl + 128]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 5
; ScmLambdaSimple': 
; Params: null?, cons, last-elem, without-last-elem, fold-right
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params77

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop77:
cmp rsi, -1
je end_copy_env_loop77
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop77
end_copy_env_loop77:

add_zero_rib_params77:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop77:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop77
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop77
end_copy_params_loop77:
MAKE_CLOSURE(rax, rdx, Lcode77)
jmp Lcont77
Lcode77:
push rbp
mov rbp , rsp
; ScmLambdaOpt': 
; Params: 
; Optional Param: argslist
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params78

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop78:
cmp rsi, 0
je end_copy_env_loop78
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop78
end_copy_env_loop78:

add_zero_rib_params78:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop78:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop78
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop78
end_copy_params_loop78:
MAKE_CLOSURE(rax, rdx, Lcode78)
jmp Lcont78
Lcode78:
push rbp
mov rbp , rsp
mov rbx, 0 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack78

adjust_stack_to_list78:
mov rsi, [rbp + 8 * 3]
sub rsi, 0
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 0
cmp rdx, 0
jne params_length_not_zero78
mov rdx, 1
jmp decided_param_count78
params_length_not_zero78:
mov rdx, rcx
sub rdx, 0
add rdx, 1
decided_param_count78:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop78:
cmp rdi, 0
je end_create_list_loop78
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop78
end_create_list_loop78:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop78:
cmp rdi, 0
je end_push_stack_loop78
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop78
end_push_stack_loop78:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body78

add_nil_to_stack78:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop78:
cmp rdi, 0
je end_add_nil_loop78
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop78
end_add_nil_loop78:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body78:
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): argslist
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure80
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure80:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse79
; ScmConst':
mov rax, const_tbl + 1
jmp Lexit79
Lelse79:
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): argslist
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): without-last-elem
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure82
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure82:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): argslist
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): last-elem
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure83
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure83:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmVar'(VarBound): cons
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

push rax
push 3
; ScmVar'(VarBound): fold-right
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure81
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure81:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop81:
cmp rsi, 64
je end_copy_stack_loop81
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop81
end_copy_stack_loop81:
add rsp, rdi
pop rbp
jmp rax
Lexit79:
leave
ret
Lcont78:
leave
ret
Lcont77:
cmp byte [rax], T_CLOSURE
je is_closure76
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure76:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 136], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: append
; ScmApplic': 
; ScmVar'(VarFree): cons
mov rax, qword [fvar_tbl + 128]
push rax
; ScmVar'(VarFree): fold-right
mov rax, qword [fvar_tbl + 192]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 3
; ScmLambdaSimple': 
; Params: null?, fold-right, cons
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params85

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop85:
cmp rsi, -1
je end_copy_env_loop85
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop85
end_copy_env_loop85:

add_zero_rib_params85:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop85:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop85
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop85
end_copy_params_loop85:
MAKE_CLOSURE(rax, rdx, Lcode85)
jmp Lcont85
Lcode85:
push rbp
mov rbp , rsp
; ScmLambdaOpt': 
; Params: 
; Optional Param: args
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params86

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop86:
cmp rsi, 0
je end_copy_env_loop86
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop86
end_copy_env_loop86:

add_zero_rib_params86:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop86:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop86
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop86
end_copy_params_loop86:
MAKE_CLOSURE(rax, rdx, Lcode86)
jmp Lcont86
Lcode86:
push rbp
mov rbp , rsp
mov rbx, 0 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack86

adjust_stack_to_list86:
mov rsi, [rbp + 8 * 3]
sub rsi, 0
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 0
cmp rdx, 0
jne params_length_not_zero86
mov rdx, 1
jmp decided_param_count86
params_length_not_zero86:
mov rdx, rcx
sub rdx, 0
add rdx, 1
decided_param_count86:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop86:
cmp rdi, 0
je end_create_list_loop86
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop86
end_create_list_loop86:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop86:
cmp rdi, 0
je end_push_stack_loop86
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop86
end_push_stack_loop86:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body86

add_nil_to_stack86:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop86:
cmp rdi, 0
je end_add_nil_loop86
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop86
end_add_nil_loop86:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body86:
; ScmApplicTP': 
;ScmVar'(VarParam): args
mov rax, qword [rbp + 8 * 4]
push rax
; ScmConst':
mov rax, const_tbl + 1
push rax
; ScmLambdaSimple': 
; Params: e, a
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params88

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop88:
cmp rsi, 1
je end_copy_env_loop88
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop88
end_copy_env_loop88:

add_zero_rib_params88:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop88:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop88
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop88
end_copy_params_loop88:
MAKE_CLOSURE(rax, rdx, Lcode88)
jmp Lcont88
Lcode88:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): a
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure90
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure90:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse89
;ScmVar'(VarParam): e
mov rax, qword [rbp + 8 * 4]
jmp Lexit89
Lelse89:
; ScmApplicTP': 
;ScmVar'(VarParam): e
mov rax, qword [rbp + 8 * 4]
push rax
;ScmVar'(VarParam): a
mov rax, qword [rbp + 8 * 5]
push rax
; ScmVar'(VarBound): cons
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]

push rax
push 3
; ScmVar'(VarBound): fold-right
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure91
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure91:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop91:
cmp rsi, 64
je end_copy_stack_loop91
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop91
end_copy_stack_loop91:
add rsp, rdi
pop rbp
jmp rax
Lexit89:
leave
ret
Lcont88:

push rax
push 3
; ScmVar'(VarBound): fold-right
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure87
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure87:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop87:
cmp rsi, 64
je end_copy_stack_loop87
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop87
end_copy_stack_loop87:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont86:
leave
ret
Lcont85:
cmp byte [rax], T_CLOSURE
je is_closure84
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure84:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 72], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: list
; ScmLambdaOpt': 
; Params: 
; Optional Param: x
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params92

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop92:
cmp rsi, -1
je end_copy_env_loop92
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop92
end_copy_env_loop92:

add_zero_rib_params92:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop92:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop92
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop92
end_copy_params_loop92:
MAKE_CLOSURE(rax, rdx, Lcode92)
jmp Lcont92
Lcode92:
push rbp
mov rbp , rsp
mov rbx, 0 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack92

adjust_stack_to_list92:
mov rsi, [rbp + 8 * 3]
sub rsi, 0
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 0
cmp rdx, 0
jne params_length_not_zero92
mov rdx, 1
jmp decided_param_count92
params_length_not_zero92:
mov rdx, rcx
sub rdx, 0
add rdx, 1
decided_param_count92:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop92:
cmp rdi, 0
je end_create_list_loop92
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop92
end_create_list_loop92:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop92:
cmp rdi, 0
je end_push_stack_loop92
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop92
end_push_stack_loop92:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body92

add_nil_to_stack92:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop92:
cmp rdi, 0
je end_add_nil_loop92
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop92
end_add_nil_loop92:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body92:
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
leave
ret
Lcont92:
mov qword [fvar_tbl + 232], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: list?
; ScmApplic': 
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): pair?
mov rax, qword [fvar_tbl + 296]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 3
; ScmLambdaSimple': 
; Params: null?, pair?, cdr
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params94

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop94:
cmp rsi, -1
je end_copy_env_loop94
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop94
end_copy_env_loop94:

add_zero_rib_params94:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop94:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop94
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop94
end_copy_params_loop94:
MAKE_CLOSURE(rax, rdx, Lcode94)
jmp Lcont94
Lcode94:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: list?-loop
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params96

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop96:
cmp rsi, 0
je end_copy_env_loop96
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop96
end_copy_env_loop96:

add_zero_rib_params96:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop96:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop96
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop96
end_copy_params_loop96:
MAKE_CLOSURE(rax, rdx, Lcode96)
jmp Lcont96
Lcode96:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: list?-loop
; ScmBox':
;ScmVar'(VarParam): list?-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: x
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params97

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop97:
cmp rsi, 1
je end_copy_env_loop97
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop97
end_copy_env_loop97:

add_zero_rib_params97:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop97:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop97
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop97
end_copy_params_loop97:
MAKE_CLOSURE(rax, rdx, Lcode97)
jmp Lcont97
Lcode97:
push rbp
mov rbp , rsp
; ScmOr': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure99
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure99:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
jne Lexit98
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): pair?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure101
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure101:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse100
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure103
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure103:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmBoxGet':
; ScmVar'(VarBound): list?-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure102
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure102:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop102:
cmp rsi, 48
je end_copy_stack_loop102
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop102
end_copy_stack_loop102:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit100
Lelse100:
; ScmConst':
mov rax, const_tbl + 2
Lexit100:
Lexit98:
leave
ret
Lcont97:
mov rbx, rax
;ScmVar'(VarParam): list?-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmBoxGet':
;ScmVar'(VarParam): list?-loop
mov rax, qword [rbp + 8 * 4]
CAR rax, rax
leave
ret
Lcont96:
cmp byte [rax], T_CLOSURE
je is_closure95
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure95:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop95:
cmp rsi, 48
je end_copy_stack_loop95
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop95
end_copy_stack_loop95:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont94:
cmp byte [rax], T_CLOSURE
je is_closure93
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure93:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 240], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: make-string
; ScmApplic': 
; ScmVar'(VarFree): make-string
mov rax, qword [fvar_tbl + 248]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 3
; ScmLambdaSimple': 
; Params: null?, car, make-string
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params105

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop105:
cmp rsi, -1
je end_copy_env_loop105
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop105
end_copy_env_loop105:

add_zero_rib_params105:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop105:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop105
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop105
end_copy_params_loop105:
MAKE_CLOSURE(rax, rdx, Lcode105)
jmp Lcont105
Lcode105:
push rbp
mov rbp , rsp
; ScmLambdaOpt': 
; Params: x
; Optional Param: y
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params106

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop106:
cmp rsi, 0
je end_copy_env_loop106
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop106
end_copy_env_loop106:

add_zero_rib_params106:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop106:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop106
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop106
end_copy_params_loop106:
MAKE_CLOSURE(rax, rdx, Lcode106)
jmp Lcont106
Lcode106:
push rbp
mov rbp , rsp
mov rbx, 1 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack106

adjust_stack_to_list106:
mov rsi, [rbp + 8 * 3]
sub rsi, 1
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 1
cmp rdx, 0
jne params_length_not_zero106
mov rdx, 1
jmp decided_param_count106
params_length_not_zero106:
mov rdx, rcx
sub rdx, 1
add rdx, 1
decided_param_count106:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop106:
cmp rdi, 0
je end_create_list_loop106
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop106
end_create_list_loop106:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop106:
cmp rdi, 0
je end_push_stack_loop106
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop106
end_push_stack_loop106:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body106

add_nil_to_stack106:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop106:
cmp rdi, 0
je end_add_nil_loop106
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop106
end_add_nil_loop106:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body106:
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure108
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure108:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse107
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 32
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): make-string
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure109
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure109:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop109:
cmp rsi, 56
je end_copy_stack_loop109
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop109
end_copy_stack_loop109:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit107
Lelse107:
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure111
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure111:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): make-string
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure110
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure110:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop110:
cmp rsi, 56
je end_copy_stack_loop110
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop110
end_copy_stack_loop110:
add rsp, rdi
pop rbp
jmp rax
Lexit107:
leave
ret
Lcont106:
leave
ret
Lcont105:
cmp byte [rax], T_CLOSURE
je is_closure104
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure104:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 248], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: not
; ScmLambdaSimple': 
; Params: x
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params112

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop112:
cmp rsi, -1
je end_copy_env_loop112
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop112
end_copy_env_loop112:

add_zero_rib_params112:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop112:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop112
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop112
end_copy_params_loop112:
MAKE_CLOSURE(rax, rdx, Lcode112)
jmp Lcont112
Lcode112:
push rbp
mov rbp , rsp
; ScmIf': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
cmp rax, SOB_FALSE_ADDRESS
je Lelse113
; ScmConst':
mov rax, const_tbl + 2
jmp Lexit113
Lelse113:
; ScmConst':
mov rax, const_tbl + 4
Lexit113:
leave
ret
Lcont112:
mov qword [fvar_tbl + 264], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmApplic': 
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]
push rax
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): <
mov rax, qword [fvar_tbl + 48]
push rax
; ScmVar'(VarFree): =
mov rax, qword [fvar_tbl + 56]
push rax
; ScmVar'(VarFree): /
mov rax, qword [fvar_tbl + 40]
push rax
; ScmVar'(VarFree): *
mov rax, qword [fvar_tbl + 16]
push rax
; ScmVar'(VarFree): +
mov rax, qword [fvar_tbl + 24]
push rax
; ScmVar'(VarFree): map
mov rax, qword [fvar_tbl + 256]
push rax
; ScmVar'(VarFree): fold-left
mov rax, qword [fvar_tbl + 184]
push rax
; ScmVar'(VarFree): exact->inexact
mov rax, qword [fvar_tbl + 168]
push rax
; ScmVar'(VarFree): rational?
mov rax, qword [fvar_tbl + 312]
push rax
; ScmVar'(VarFree): flonum?
mov rax, qword [fvar_tbl + 176]

push rax
push 13
; ScmLambdaSimple': 
; Params: flonum?, rational?, exact->inexact, fold-left, map, _+, _*, _/, _=, _<, car, cdr, null?
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params115

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop115:
cmp rsi, -1
je end_copy_env_loop115
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop115
end_copy_env_loop115:

add_zero_rib_params115:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop115:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop115
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop115
end_copy_params_loop115:
MAKE_CLOSURE(rax, rdx, Lcode115)
jmp Lcont115
Lcode115:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmLambdaSimple': 
; Params: op
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params152

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop152:
cmp rsi, 0
je end_copy_env_loop152
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop152
end_copy_env_loop152:

add_zero_rib_params152:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop152:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop152
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop152
end_copy_params_loop152:
MAKE_CLOSURE(rax, rdx, Lcode152)
jmp Lcont152
Lcode152:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: x, y
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params153

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop153:
cmp rsi, 1
je end_copy_env_loop153
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop153
end_copy_env_loop153:

add_zero_rib_params153:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop153:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop153
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop153
end_copy_params_loop153:
MAKE_CLOSURE(rax, rdx, Lcode153)
jmp Lcont153
Lcode153:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): flonum?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure156
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure156:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse155
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): rational?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure157
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure157:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
jmp Lexit155
Lelse155:
; ScmConst':
mov rax, const_tbl + 2
Lexit155:
cmp rax, SOB_FALSE_ADDRESS
je Lelse154
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): exact->inexact
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure159
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure159:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): op
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure158
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure158:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop158:
cmp rsi, 56
je end_copy_stack_loop158
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop158
end_copy_stack_loop158:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit154
Lelse154:
; ScmIf': 
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): rational?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure162
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure162:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse161
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): flonum?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure163
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure163:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
jmp Lexit161
Lelse161:
; ScmConst':
mov rax, const_tbl + 2
Lexit161:
cmp rax, SOB_FALSE_ADDRESS
je Lelse160
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): exact->inexact
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure165
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure165:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarBound): op
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure164
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure164:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop164:
cmp rsi, 56
je end_copy_stack_loop164
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop164
end_copy_stack_loop164:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit160
Lelse160:
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): op
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure166
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure166:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop166:
cmp rsi, 56
je end_copy_stack_loop166
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop166
end_copy_stack_loop166:
add rsp, rdi
pop rbp
jmp rax
Lexit160:
Lexit154:
leave
ret
Lcont153:
leave
ret
Lcont152:

push rax
push 1
; ScmLambdaSimple': 
; Params: ^numeric-op-dispatcher
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params117

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop117:
cmp rsi, 0
je end_copy_env_loop117
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop117
end_copy_env_loop117:

add_zero_rib_params117:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop117:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop117
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop117
end_copy_params_loop117:
MAKE_CLOSURE(rax, rdx, Lcode117)
jmp Lcont117
Lcode117:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarFree: +
; ScmLambdaOpt': 
; Params: 
; Optional Param: x
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params118

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop118:
cmp rsi, 1
je end_copy_env_loop118
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop118
end_copy_env_loop118:

add_zero_rib_params118:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop118:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop118
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop118
end_copy_params_loop118:
MAKE_CLOSURE(rax, rdx, Lcode118)
jmp Lcont118
Lcode118:
push rbp
mov rbp , rsp
mov rbx, 0 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack118

adjust_stack_to_list118:
mov rsi, [rbp + 8 * 3]
sub rsi, 0
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 0
cmp rdx, 0
jne params_length_not_zero118
mov rdx, 1
jmp decided_param_count118
params_length_not_zero118:
mov rdx, rcx
sub rdx, 0
add rdx, 1
decided_param_count118:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop118:
cmp rdi, 0
je end_create_list_loop118
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop118
end_create_list_loop118:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop118:
cmp rdi, 0
je end_push_stack_loop118
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop118
end_push_stack_loop118:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body118

add_nil_to_stack118:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop118:
cmp rdi, 0
je end_add_nil_loop118
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop118
end_add_nil_loop118:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body118:
; ScmApplicTP': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
push rax
; ScmConst':
mov rax, const_tbl + 34
push rax
; ScmApplic': 
; ScmVar'(VarBound): _+
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): ^numeric-op-dispatcher
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure120
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure120:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 3
; ScmVar'(VarBound): fold-left
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure119
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure119:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop119:
cmp rsi, 64
je end_copy_stack_loop119
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop119
end_copy_stack_loop119:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont118:
mov qword [fvar_tbl + 24], rax
mov rax, SOB_VOID_ADDRESS
; ScmSet':
; VarFree: *
; ScmLambdaOpt': 
; Params: 
; Optional Param: x
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params121

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop121:
cmp rsi, 1
je end_copy_env_loop121
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop121
end_copy_env_loop121:

add_zero_rib_params121:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop121:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop121
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop121
end_copy_params_loop121:
MAKE_CLOSURE(rax, rdx, Lcode121)
jmp Lcont121
Lcode121:
push rbp
mov rbp , rsp
mov rbx, 0 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack121

adjust_stack_to_list121:
mov rsi, [rbp + 8 * 3]
sub rsi, 0
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 0
cmp rdx, 0
jne params_length_not_zero121
mov rdx, 1
jmp decided_param_count121
params_length_not_zero121:
mov rdx, rcx
sub rdx, 0
add rdx, 1
decided_param_count121:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop121:
cmp rdi, 0
je end_create_list_loop121
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop121
end_create_list_loop121:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop121:
cmp rdi, 0
je end_push_stack_loop121
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop121
end_push_stack_loop121:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body121

add_nil_to_stack121:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop121:
cmp rdi, 0
je end_add_nil_loop121
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop121
end_add_nil_loop121:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body121:
; ScmApplicTP': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
push rax
; ScmConst':
mov rax, const_tbl + 51
push rax
; ScmApplic': 
; ScmVar'(VarBound): _*
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 6]

push rax
push 1
; ScmVar'(VarBound): ^numeric-op-dispatcher
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure123
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure123:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 3
; ScmVar'(VarBound): fold-left
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure122
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure122:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop122:
cmp rsi, 64
je end_copy_stack_loop122
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop122
end_copy_stack_loop122:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont121:
mov qword [fvar_tbl + 16], rax
mov rax, SOB_VOID_ADDRESS
; ScmSet':
; VarFree: /
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): _/
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 7]

push rax
push 1
;ScmVar'(VarParam): ^numeric-op-dispatcher
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure131
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure131:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmLambdaSimple': 
; Params: /
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params125

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop125:
cmp rsi, 1
je end_copy_env_loop125
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop125
end_copy_env_loop125:

add_zero_rib_params125:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop125:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop125
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop125
end_copy_params_loop125:
MAKE_CLOSURE(rax, rdx, Lcode125)
jmp Lcont125
Lcode125:
push rbp
mov rbp , rsp
; ScmLambdaOpt': 
; Params: x
; Optional Param: y
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params126

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop126:
cmp rsi, 2
je end_copy_env_loop126
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop126
end_copy_env_loop126:

add_zero_rib_params126:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop126:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop126
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop126
end_copy_params_loop126:
MAKE_CLOSURE(rax, rdx, Lcode126)
jmp Lcont126
Lcode126:
push rbp
mov rbp , rsp
mov rbx, 1 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack126

adjust_stack_to_list126:
mov rsi, [rbp + 8 * 3]
sub rsi, 1
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 1
cmp rdx, 0
jne params_length_not_zero126
mov rdx, 1
jmp decided_param_count126
params_length_not_zero126:
mov rdx, rcx
sub rdx, 1
add rdx, 1
decided_param_count126:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop126:
cmp rdi, 0
je end_create_list_loop126
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop126
end_create_list_loop126:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop126:
cmp rdi, 0
je end_push_stack_loop126
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop126
end_push_stack_loop126:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body126

add_nil_to_stack126:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop126:
cmp rdi, 0
je end_add_nil_loop126
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop126
end_add_nil_loop126:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body126:
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 12]
cmp byte [rax], T_CLOSURE
je is_closure128
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure128:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse127
; ScmApplicTP': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
push rax
; ScmConst':
mov rax, const_tbl + 51

push rax
push 2
; ScmVar'(VarBound): /
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure129
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure129:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop129:
cmp rsi, 56
je end_copy_stack_loop129
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop129
end_copy_stack_loop129:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit127
Lelse127:
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
push rax
; ScmVar'(VarBound): /
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 3
; ScmVar'(VarBound): fold-left
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure130
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure130:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop130:
cmp rsi, 64
je end_copy_stack_loop130
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop130
end_copy_stack_loop130:
add rsp, rdi
pop rbp
jmp rax
Lexit127:
leave
ret
Lcont126:
leave
ret
Lcont125:
cmp byte [rax], T_CLOSURE
je is_closure124
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure124:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 40], rax
mov rax, SOB_VOID_ADDRESS
; ScmApplicTP': 
; ScmLambdaSimple': 
; Params: op
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params138

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop138:
cmp rsi, 1
je end_copy_env_loop138
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop138
end_copy_env_loop138:

add_zero_rib_params138:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop138:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop138
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop138
end_copy_params_loop138:
MAKE_CLOSURE(rax, rdx, Lcode138)
jmp Lcont138
Lcode138:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: comparator
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params140

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop140:
cmp rsi, 2
je end_copy_env_loop140
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop140
end_copy_env_loop140:

add_zero_rib_params140:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop140:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop140
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop140
end_copy_params_loop140:
MAKE_CLOSURE(rax, rdx, Lcode140)
jmp Lcont140
Lcode140:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: comparator
; ScmBox':
;ScmVar'(VarParam): comparator
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: x, ys
mov rdx, 5
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params141

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop141:
cmp rsi, 3
je end_copy_env_loop141
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop141
end_copy_env_loop141:

add_zero_rib_params141:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop141:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop141
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop141
end_copy_params_loop141:
MAKE_CLOSURE(rax, rdx, Lcode141)
jmp Lcont141
Lcode141:
push rbp
mov rbp , rsp
; ScmOr': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 12]
cmp byte [rax], T_CLOSURE
je is_closure143
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure143:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
jne Lexit142
; ScmIf': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 10]
cmp byte [rax], T_CLOSURE
je is_closure146
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure146:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): op
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure145
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure145:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse144
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 11]
cmp byte [rax], T_CLOSURE
je is_closure148
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure148:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 3]
mov rax, qword [rax + 8 * 10]
cmp byte [rax], T_CLOSURE
je is_closure149
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure149:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): comparator
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure147
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure147:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop147:
cmp rsi, 56
je end_copy_stack_loop147
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop147
end_copy_stack_loop147:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit144
Lelse144:
; ScmConst':
mov rax, const_tbl + 2
Lexit144:
Lexit142:
leave
ret
Lcont141:
mov rbx, rax
;ScmVar'(VarParam): comparator
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmLambdaOpt': 
; Params: x
; Optional Param: y
mov rdx, 5
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params150

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop150:
cmp rsi, 3
je end_copy_env_loop150
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop150
end_copy_env_loop150:

add_zero_rib_params150:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop150:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop150
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop150
end_copy_params_loop150:
MAKE_CLOSURE(rax, rdx, Lcode150)
jmp Lcont150
Lcode150:
push rbp
mov rbp , rsp
mov rbx, 1 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack150

adjust_stack_to_list150:
mov rsi, [rbp + 8 * 3]
sub rsi, 1
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 1
cmp rdx, 0
jne params_length_not_zero150
mov rdx, 1
jmp decided_param_count150
params_length_not_zero150:
mov rdx, rcx
sub rdx, 1
add rdx, 1
decided_param_count150:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop150:
cmp rdi, 0
je end_create_list_loop150
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop150
end_create_list_loop150:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop150:
cmp rdi, 0
je end_push_stack_loop150
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop150
end_push_stack_loop150:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body150

add_nil_to_stack150:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop150:
cmp rdi, 0
je end_add_nil_loop150
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop150
end_add_nil_loop150:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body150:
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): comparator
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure151
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure151:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop151:
cmp rsi, 56
je end_copy_stack_loop151
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop151
end_copy_stack_loop151:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont150:
leave
ret
Lcont140:
cmp byte [rax], T_CLOSURE
je is_closure139
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure139:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop139:
cmp rsi, 48
je end_copy_stack_loop139
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop139
end_copy_stack_loop139:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont138:

push rax
push 1
; ScmLambdaSimple': 
; Params: ^comparator
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params133

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop133:
cmp rsi, 1
je end_copy_env_loop133
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop133
end_copy_env_loop133:

add_zero_rib_params133:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop133:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop133
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop133
end_copy_params_loop133:
MAKE_CLOSURE(rax, rdx, Lcode133)
jmp Lcont133
Lcode133:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarFree: =
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): _=
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 8]

push rax
push 1
; ScmVar'(VarBound): ^numeric-op-dispatcher
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure135
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure135:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
;ScmVar'(VarParam): ^comparator
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure134
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure134:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 56], rax
mov rax, SOB_VOID_ADDRESS
; ScmSet':
; VarFree: <
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): _<
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 9]

push rax
push 1
; ScmVar'(VarBound): ^numeric-op-dispatcher
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure137
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure137:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
;ScmVar'(VarParam): ^comparator
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure136
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure136:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 48], rax
mov rax, SOB_VOID_ADDRESS
leave
ret
Lcont133:
cmp byte [rax], T_CLOSURE
je is_closure132
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure132:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop132:
cmp rsi, 48
je end_copy_stack_loop132
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop132
end_copy_stack_loop132:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont117:
cmp byte [rax], T_CLOSURE
je is_closure116
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure116:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop116:
cmp rsi, 48
je end_copy_stack_loop116
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop116
end_copy_stack_loop116:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont115:
cmp byte [rax], T_CLOSURE
je is_closure114
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure114:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

	call write_sob_if_not_void

; ScmDef':
; VarFree: -
; ScmApplic': 
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]
push rax
; ScmVar'(VarFree): +
mov rax, qword [fvar_tbl + 24]
push rax
; ScmVar'(VarFree): apply
mov rax, qword [fvar_tbl + 80]

push rax
push 3
; ScmLambdaSimple': 
; Params: apply, +, null?
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params168

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop168:
cmp rsi, -1
je end_copy_env_loop168
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop168
end_copy_env_loop168:

add_zero_rib_params168:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop168:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop168
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop168
end_copy_params_loop168:
MAKE_CLOSURE(rax, rdx, Lcode168)
jmp Lcont168
Lcode168:
push rbp
mov rbp , rsp
; ScmLambdaOpt': 
; Params: x
; Optional Param: y
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params169

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop169:
cmp rsi, 0
je end_copy_env_loop169
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop169
end_copy_env_loop169:

add_zero_rib_params169:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop169:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop169
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop169
end_copy_params_loop169:
MAKE_CLOSURE(rax, rdx, Lcode169)
jmp Lcont169
Lcode169:
push rbp
mov rbp , rsp
mov rbx, 1 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack169

adjust_stack_to_list169:
mov rsi, [rbp + 8 * 3]
sub rsi, 1
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 1
cmp rdx, 0
jne params_length_not_zero169
mov rdx, 1
jmp decided_param_count169
params_length_not_zero169:
mov rdx, rcx
sub rdx, 1
add rdx, 1
decided_param_count169:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop169:
cmp rdi, 0
je end_create_list_loop169
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop169
end_create_list_loop169:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop169:
cmp rdi, 0
je end_push_stack_loop169
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop169
end_push_stack_loop169:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body169

add_nil_to_stack169:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop169:
cmp rdi, 0
je end_add_nil_loop169
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop169
end_add_nil_loop169:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body169:
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure171
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure171:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse170
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
push rax
; ScmConst':
mov rax, const_tbl + 68

push rax
push 2
; ScmVar'(VarFree): *
mov rax, qword [fvar_tbl + 16]
cmp byte [rax], T_CLOSURE
je is_closure173
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure173:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmConst':
mov rax, const_tbl + 34

push rax
push 2
; ScmVar'(VarBound): +
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure172
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure172:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop172:
cmp rsi, 56
je end_copy_stack_loop172
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop172
end_copy_stack_loop172:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit170
Lelse170:
; ScmApplicTP': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
; ScmVar'(VarBound): +
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]

push rax
push 2
; ScmVar'(VarBound): apply
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure176
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure176:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmConst':
mov rax, const_tbl + 68

push rax
push 2
; ScmVar'(VarFree): *
mov rax, qword [fvar_tbl + 16]
cmp byte [rax], T_CLOSURE
je is_closure175
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure175:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): +
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure174
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure174:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop174:
cmp rsi, 56
je end_copy_stack_loop174
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop174
end_copy_stack_loop174:
add rsp, rdi
pop rbp
jmp rax
Lexit170:
leave
ret
Lcont169:
leave
ret
Lcont168:
cmp byte [rax], T_CLOSURE
je is_closure167
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure167:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 32], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: >
; ScmApplic': 
; ScmVar'(VarFree): =
mov rax, qword [fvar_tbl + 56]
push rax
; ScmVar'(VarFree): <
mov rax, qword [fvar_tbl + 48]
push rax
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): not
mov rax, qword [fvar_tbl + 264]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]

push rax
push 6
; ScmLambdaSimple': 
; Params: null?, not, car, cdr, <, =
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params178

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop178:
cmp rsi, -1
je end_copy_env_loop178
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop178
end_copy_env_loop178:

add_zero_rib_params178:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop178:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop178
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop178
end_copy_params_loop178:
MAKE_CLOSURE(rax, rdx, Lcode178)
jmp Lcont178
Lcode178:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: >-loop
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params180

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop180:
cmp rsi, 0
je end_copy_env_loop180
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop180
end_copy_env_loop180:

add_zero_rib_params180:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop180:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop180
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop180
end_copy_params_loop180:
MAKE_CLOSURE(rax, rdx, Lcode180)
jmp Lcont180
Lcode180:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: >-loop
; ScmBox':
;ScmVar'(VarParam): >-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: x, ys
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params181

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop181:
cmp rsi, 1
je end_copy_env_loop181
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop181
end_copy_env_loop181:

add_zero_rib_params181:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop181:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop181
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop181
end_copy_params_loop181:
MAKE_CLOSURE(rax, rdx, Lcode181)
jmp Lcont181
Lcode181:
push rbp
mov rbp , rsp
; ScmOr': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure183
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure183:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
jne Lexit182
; ScmIf': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure187
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure187:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): <
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure186
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure186:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): not
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure185
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure185:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse184
; ScmIf': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure191
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure191:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): =
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]
cmp byte [rax], T_CLOSURE
je is_closure190
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure190:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): not
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure189
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure189:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse188
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure193
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure193:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure194
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure194:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): >-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure192
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure192:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop192:
cmp rsi, 56
je end_copy_stack_loop192
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop192
end_copy_stack_loop192:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit188
Lelse188:
; ScmConst':
mov rax, const_tbl + 2
Lexit188:
jmp Lexit184
Lelse184:
; ScmConst':
mov rax, const_tbl + 2
Lexit184:
Lexit182:
leave
ret
Lcont181:
mov rbx, rax
;ScmVar'(VarParam): >-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmLambdaOpt': 
; Params: x
; Optional Param: y
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params195

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop195:
cmp rsi, 1
je end_copy_env_loop195
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop195
end_copy_env_loop195:

add_zero_rib_params195:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop195:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop195
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop195
end_copy_params_loop195:
MAKE_CLOSURE(rax, rdx, Lcode195)
jmp Lcont195
Lcode195:
push rbp
mov rbp , rsp
mov rbx, 1 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack195

adjust_stack_to_list195:
mov rsi, [rbp + 8 * 3]
sub rsi, 1
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 1
cmp rdx, 0
jne params_length_not_zero195
mov rdx, 1
jmp decided_param_count195
params_length_not_zero195:
mov rdx, rcx
sub rdx, 1
add rdx, 1
decided_param_count195:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop195:
cmp rdi, 0
je end_create_list_loop195
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop195
end_create_list_loop195:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop195:
cmp rdi, 0
je end_push_stack_loop195
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop195
end_push_stack_loop195:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body195

add_nil_to_stack195:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop195:
cmp rdi, 0
je end_add_nil_loop195
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop195
end_add_nil_loop195:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body195:
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): >-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure196
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure196:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop196:
cmp rsi, 56
je end_copy_stack_loop196
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop196
end_copy_stack_loop196:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont195:
leave
ret
Lcont180:
cmp byte [rax], T_CLOSURE
je is_closure179
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure179:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop179:
cmp rsi, 48
je end_copy_stack_loop179
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop179
end_copy_stack_loop179:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont178:
cmp byte [rax], T_CLOSURE
je is_closure177
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure177:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 64], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: gcd
; ScmApplic': 
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): null?
mov rax, qword [fvar_tbl + 272]
push rax
; ScmVar'(VarFree): gcd
mov rax, qword [fvar_tbl + 200]

push rax
push 4
; ScmLambdaSimple': 
; Params: gcd, null?, car, cdr
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params198

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop198:
cmp rsi, -1
je end_copy_env_loop198
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop198
end_copy_env_loop198:

add_zero_rib_params198:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop198:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop198
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop198
end_copy_params_loop198:
MAKE_CLOSURE(rax, rdx, Lcode198)
jmp Lcont198
Lcode198:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: gcd-loop
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params200

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop200:
cmp rsi, 0
je end_copy_env_loop200
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop200
end_copy_env_loop200:

add_zero_rib_params200:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop200:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop200
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop200
end_copy_params_loop200:
MAKE_CLOSURE(rax, rdx, Lcode200)
jmp Lcont200
Lcode200:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: gcd-loop
; ScmBox':
;ScmVar'(VarParam): gcd-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: x, ys
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params201

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop201:
cmp rsi, 1
je end_copy_env_loop201
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop201
end_copy_env_loop201:

add_zero_rib_params201:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop201:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop201
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop201
end_copy_params_loop201:
MAKE_CLOSURE(rax, rdx, Lcode201)
jmp Lcont201
Lcode201:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure203
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure203:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse202
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
jmp Lexit202
Lelse202:
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure205
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure205:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): ys
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure207
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure207:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): gcd
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure206
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure206:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): gcd-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure204
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure204:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop204:
cmp rsi, 56
je end_copy_stack_loop204
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop204
end_copy_stack_loop204:
add rsp, rdi
pop rbp
jmp rax
Lexit202:
leave
ret
Lcont201:
mov rbx, rax
;ScmVar'(VarParam): gcd-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmLambdaOpt': 
; Params: 
; Optional Param: x
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params208

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop208:
cmp rsi, 1
je end_copy_env_loop208
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop208
end_copy_env_loop208:

add_zero_rib_params208:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop208:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop208
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop208
end_copy_params_loop208:
MAKE_CLOSURE(rax, rdx, Lcode208)
jmp Lcont208
Lcode208:
push rbp
mov rbp , rsp
mov rbx, 0 ; Number of params
mov rcx, [rbp + 8 * 3] ; Number of args on stack
cmp rbx, rcx
je add_nil_to_stack208

adjust_stack_to_list208:
mov rsi, [rbp + 8 * 3]
sub rsi, 0
sub rsi, 1 ; rsi holds the amount of blocks we need to push later
mov rax, SOB_NIL_ADDRESS ; cdr
sub rcx, rbx ; rcx has the amount of extra args on stack
mov rdi, rcx ; now rdi has it ^
mov rcx, [rbp + 8 * 3] ; Number of args on stack
mov rdx, 0
cmp rdx, 0
jne params_length_not_zero208
mov rdx, 1
jmp decided_param_count208
params_length_not_zero208:
mov rdx, rcx
sub rdx, 0
add rdx, 1
decided_param_count208:
mov qword [rbp + 8 * 3], rdx ; updating number of params on stack
dec rcx
add rcx, 4 ; rcx has the offset of the last arg
shl rcx, 3 ; 8*
add rcx, rbp
push rcx ; save it for later
create_list_loop208:
cmp rdi, 0
je end_create_list_loop208
mov rbx, qword [rcx] ; car
MAKE_PAIR(rdx, rbx, rax) ; rdx has new list
mov rax, rdx ; now rax has it ^
sub rcx, 8
dec rdi
jmp create_list_loop208
end_create_list_loop208:
pop rcx ; rcx now points to the last argument on stack
mov qword [rcx], rax ; new list is now in the correct place
; now lets push the stack up
mov rdx, qword [rbp + 8 * 3]
dec rdx
dec rdx ; offset of first arg to push up
mov rcx, rdx
add rcx, rsi ; offset of the block we need to push to
add rdx, 4
shl rdx, 3
add rdx, rbp
mov rbx, rdx ; push from
add rcx, 4
shl rcx, 3
add rcx, rbp ; push to
mov rdi, qword [rbp + 8 * 3] ; correct number of arguments on stack
dec rdi ; the list
add rdi, 4
push_stack_loop208:
cmp rdi, 0
je end_push_stack_loop208
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
dec rdi
jmp push_stack_loop208
end_push_stack_loop208:
shl rsi, 3 ; push rbp and rsp up
add rbp, rsi
add rsp, rsi
jmp body208

add_nil_to_stack208:
mov rdi, rcx ; counter
add rdi, 4
inc rbx
mov qword [rbp + 8 * 3], rbx ; +1 for nil
mov rbx, rbp ; Copy from
mov rcx, rbp ; Copy to
sub rcx, 8
add_nil_loop208:
cmp rdi, 0
je end_add_nil_loop208
mov rdx, qword [rbx]
mov qword [rcx], rdx
add rbx, 8 ; Next block to copy from
add rcx, 8 ; Next block to copy to
dec rdi
jmp add_nil_loop208
end_add_nil_loop208:
mov qword [rcx], SOB_NIL_ADDRESS
sub rbp, 8 ; rbp now points 1 block lower
sub rsp, 8 ; rsp now points 1 block lower

body208:
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): null?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure210
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure210:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse209
; ScmConst':
mov rax, const_tbl + 34
jmp Lexit209
Lelse209:
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure212
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure212:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure213
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure213:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): gcd-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure211
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure211:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop211:
cmp rsi, 56
je end_copy_stack_loop211
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop211
end_copy_stack_loop211:
add rsp, rdi
pop rbp
jmp rax
Lexit209:
leave
ret
Lcont208:
leave
ret
Lcont200:
cmp byte [rax], T_CLOSURE
je is_closure199
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure199:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop199:
cmp rsi, 48
je end_copy_stack_loop199
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop199
end_copy_stack_loop199:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont198:
cmp byte [rax], T_CLOSURE
je is_closure197
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure197:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 200], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: zero?
; ScmApplic': 
; ScmVar'(VarFree): =
mov rax, qword [fvar_tbl + 56]

push rax
push 1
; ScmLambdaSimple': 
; Params: =
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params215

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop215:
cmp rsi, -1
je end_copy_env_loop215
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop215
end_copy_env_loop215:

add_zero_rib_params215:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop215:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop215
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop215
end_copy_params_loop215:
MAKE_CLOSURE(rax, rdx, Lcode215)
jmp Lcont215
Lcode215:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: x
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params216

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop216:
cmp rsi, 0
je end_copy_env_loop216
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop216
end_copy_env_loop216:

add_zero_rib_params216:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop216:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop216
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop216
end_copy_params_loop216:
MAKE_CLOSURE(rax, rdx, Lcode216)
jmp Lcont216
Lcode216:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 34
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): =
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure217
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure217:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop217:
cmp rsi, 56
je end_copy_stack_loop217
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop217
end_copy_stack_loop217:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont216:
leave
ret
Lcont215:
cmp byte [rax], T_CLOSURE
je is_closure214
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure214:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 392], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: integer?
; ScmApplic': 
; ScmVar'(VarFree): denominator
mov rax, qword [fvar_tbl + 144]
push rax
; ScmVar'(VarFree): =
mov rax, qword [fvar_tbl + 56]
push rax
; ScmVar'(VarFree): rational?
mov rax, qword [fvar_tbl + 312]

push rax
push 3
; ScmLambdaSimple': 
; Params: rational?, =, denominator
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params219

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop219:
cmp rsi, -1
je end_copy_env_loop219
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop219
end_copy_env_loop219:

add_zero_rib_params219:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop219:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop219
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop219
end_copy_params_loop219:
MAKE_CLOSURE(rax, rdx, Lcode219)
jmp Lcont219
Lcode219:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: x
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params220

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop220:
cmp rsi, 0
je end_copy_env_loop220
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop220
end_copy_env_loop220:

add_zero_rib_params220:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop220:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop220
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop220
end_copy_params_loop220:
MAKE_CLOSURE(rax, rdx, Lcode220)
jmp Lcont220
Lcode220:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): rational?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure222
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure222:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse221
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 51
push rax
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): denominator
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure224
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure224:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarBound): =
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure223
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure223:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop223:
cmp rsi, 56
je end_copy_stack_loop223
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop223
end_copy_stack_loop223:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit221
Lelse221:
; ScmConst':
mov rax, const_tbl + 2
Lexit221:
leave
ret
Lcont220:
leave
ret
Lcont219:
cmp byte [rax], T_CLOSURE
je is_closure218
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure218:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 208], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: number?
; ScmApplic': 
; ScmVar'(VarFree): rational?
mov rax, qword [fvar_tbl + 312]
push rax
; ScmVar'(VarFree): flonum?
mov rax, qword [fvar_tbl + 176]

push rax
push 2
; ScmLambdaSimple': 
; Params: flonum?, rational?
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params226

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop226:
cmp rsi, -1
je end_copy_env_loop226
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop226
end_copy_env_loop226:

add_zero_rib_params226:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop226:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop226
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop226
end_copy_params_loop226:
MAKE_CLOSURE(rax, rdx, Lcode226)
jmp Lcont226
Lcode226:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: x
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params227

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop227:
cmp rsi, 0
je end_copy_env_loop227
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop227
end_copy_env_loop227:

add_zero_rib_params227:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop227:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop227
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop227
end_copy_params_loop227:
MAKE_CLOSURE(rax, rdx, Lcode227)
jmp Lcont227
Lcode227:
push rbp
mov rbp , rsp
; ScmOr': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): flonum?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure229
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure229:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
jne Lexit228
; ScmApplicTP': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): rational?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure230
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure230:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop230:
cmp rsi, 48
je end_copy_stack_loop230
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop230
end_copy_stack_loop230:
add rsp, rdi
pop rbp
jmp rax
Lexit228:
leave
ret
Lcont227:
leave
ret
Lcont226:
cmp byte [rax], T_CLOSURE
je is_closure225
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure225:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 280], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: length
; ScmApplic': 
; ScmVar'(VarFree): +
mov rax, qword [fvar_tbl + 24]
push rax
; ScmVar'(VarFree): fold-left
mov rax, qword [fvar_tbl + 184]

push rax
push 2
; ScmLambdaSimple': 
; Params: fold-left, +
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params232

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop232:
cmp rsi, -1
je end_copy_env_loop232
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop232
end_copy_env_loop232:

add_zero_rib_params232:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop232:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop232
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop232
end_copy_params_loop232:
MAKE_CLOSURE(rax, rdx, Lcode232)
jmp Lcont232
Lcode232:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: l
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params233

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop233:
cmp rsi, 0
je end_copy_env_loop233
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop233
end_copy_env_loop233:

add_zero_rib_params233:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop233:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop233
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop233
end_copy_params_loop233:
MAKE_CLOSURE(rax, rdx, Lcode233)
jmp Lcont233
Lcode233:
push rbp
mov rbp , rsp
; ScmApplicTP': 
;ScmVar'(VarParam): l
mov rax, qword [rbp + 8 * 4]
push rax
; ScmConst':
mov rax, const_tbl + 34
push rax
; ScmLambdaSimple': 
; Params: acc, e
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params235

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop235:
cmp rsi, 1
je end_copy_env_loop235
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop235
end_copy_env_loop235:

add_zero_rib_params235:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop235:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop235
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop235
end_copy_params_loop235:
MAKE_CLOSURE(rax, rdx, Lcode235)
jmp Lcont235
Lcode235:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 51
push rax
;ScmVar'(VarParam): acc
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): +
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure236
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure236:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop236:
cmp rsi, 56
je end_copy_stack_loop236
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop236
end_copy_stack_loop236:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont235:

push rax
push 3
; ScmVar'(VarBound): fold-left
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure234
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure234:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop234:
cmp rsi, 64
je end_copy_stack_loop234
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop234
end_copy_stack_loop234:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont233:
leave
ret
Lcont232:
cmp byte [rax], T_CLOSURE
je is_closure231
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure231:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 224], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: string->list
; ScmApplic': 
; ScmVar'(VarFree): cons
mov rax, qword [fvar_tbl + 128]
push rax
; ScmVar'(VarFree): -
mov rax, qword [fvar_tbl + 32]
push rax
; ScmVar'(VarFree): <
mov rax, qword [fvar_tbl + 48]
push rax
; ScmVar'(VarFree): string-length
mov rax, qword [fvar_tbl + 344]
push rax
; ScmVar'(VarFree): string-ref
mov rax, qword [fvar_tbl + 352]

push rax
push 5
; ScmLambdaSimple': 
; Params: string-ref, string-length, <, -, cons
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params238

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop238:
cmp rsi, -1
je end_copy_env_loop238
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop238
end_copy_env_loop238:

add_zero_rib_params238:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop238:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop238
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop238
end_copy_params_loop238:
MAKE_CLOSURE(rax, rdx, Lcode238)
jmp Lcont238
Lcode238:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: s
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params239

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop239:
cmp rsi, 0
je end_copy_env_loop239
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop239
end_copy_env_loop239:

add_zero_rib_params239:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop239:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop239
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop239
end_copy_params_loop239:
MAKE_CLOSURE(rax, rdx, Lcode239)
jmp Lcont239
Lcode239:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: s->l-loop
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params241

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop241:
cmp rsi, 1
je end_copy_env_loop241
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop241
end_copy_env_loop241:

add_zero_rib_params241:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop241:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop241
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop241
end_copy_params_loop241:
MAKE_CLOSURE(rax, rdx, Lcode241)
jmp Lcont241
Lcode241:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: s->l-loop
; ScmBox':
;ScmVar'(VarParam): s->l-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: n, a
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params242

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop242:
cmp rsi, 2
je end_copy_env_loop242
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop242
end_copy_env_loop242:

add_zero_rib_params242:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop242:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop242
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop242
end_copy_params_loop242:
MAKE_CLOSURE(rax, rdx, Lcode242)
jmp Lcont242
Lcode242:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
; ScmConst':
mov rax, const_tbl + 34
push rax
;ScmVar'(VarParam): n
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): <
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure244
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure244:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse243
;ScmVar'(VarParam): a
mov rax, qword [rbp + 8 * 5]
jmp Lexit243
Lelse243:
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): a
mov rax, qword [rbp + 8 * 5]
push rax
; ScmApplic': 
;ScmVar'(VarParam): n
mov rax, qword [rbp + 8 * 4]
push rax
; ScmVar'(VarBound): s
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]

push rax
push 2
; ScmVar'(VarBound): string-ref
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure247
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure247:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarBound): cons
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure246
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure246:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
; ScmConst':
mov rax, const_tbl + 51
push rax
;ScmVar'(VarParam): n
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): -
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 2]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure248
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure248:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): s->l-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure245
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure245:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop245:
cmp rsi, 56
je end_copy_stack_loop245
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop245
end_copy_stack_loop245:
add rsp, rdi
pop rbp
jmp rax
Lexit243:
leave
ret
Lcont242:
mov rbx, rax
;ScmVar'(VarParam): s->l-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 1
push rax
; ScmApplic': 
; ScmConst':
mov rax, const_tbl + 51
push rax
; ScmApplic': 
; ScmVar'(VarBound): s
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): string-length
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure251
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure251:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarBound): -
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure250
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure250:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
;ScmVar'(VarParam): s->l-loop
mov rax, qword [rbp + 8 * 4]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure249
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure249:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop249:
cmp rsi, 56
je end_copy_stack_loop249
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop249
end_copy_stack_loop249:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont241:
cmp byte [rax], T_CLOSURE
je is_closure240
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure240:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop240:
cmp rsi, 48
je end_copy_stack_loop240
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop240
end_copy_stack_loop240:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont239:
leave
ret
Lcont238:
cmp byte [rax], T_CLOSURE
je is_closure237
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure237:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 336], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: equal?
; ScmApplic': 
; ScmVar'(VarFree): char->integer
mov rax, qword [fvar_tbl + 112]
push rax
; ScmVar'(VarFree): cdr
mov rax, qword [fvar_tbl + 104]
push rax
; ScmVar'(VarFree): car
mov rax, qword [fvar_tbl + 96]
push rax
; ScmVar'(VarFree): eq?
mov rax, qword [fvar_tbl + 152]
push rax
; ScmVar'(VarFree): string?
mov rax, qword [fvar_tbl + 368]
push rax
; ScmVar'(VarFree): char?
mov rax, qword [fvar_tbl + 120]
push rax
; ScmVar'(VarFree): pair?
mov rax, qword [fvar_tbl + 296]
push rax
; ScmVar'(VarFree): flonum?
mov rax, qword [fvar_tbl + 176]
push rax
; ScmVar'(VarFree): rational?
mov rax, qword [fvar_tbl + 312]
push rax
; ScmVar'(VarFree): string->list
mov rax, qword [fvar_tbl + 336]
push rax
; ScmVar'(VarFree): =
mov rax, qword [fvar_tbl + 56]

push rax
push 11
; ScmLambdaSimple': 
; Params: =, string->list, rational?, flonum?, pair?, char?, string?, eq?, car, cdr, char->integer
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params253

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop253:
cmp rsi, -1
je end_copy_env_loop253
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop253
end_copy_env_loop253:

add_zero_rib_params253:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop253:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop253
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop253
end_copy_params_loop253:
MAKE_CLOSURE(rax, rdx, Lcode253)
jmp Lcont253
Lcode253:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 23

push rax
push 1
; ScmLambdaSimple': 
; Params: equal?-loop
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params255

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop255:
cmp rsi, 0
je end_copy_env_loop255
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop255
end_copy_env_loop255:

add_zero_rib_params255:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop255:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop255
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop255
end_copy_params_loop255:
MAKE_CLOSURE(rax, rdx, Lcode255)
jmp Lcont255
Lcode255:
push rbp
mov rbp , rsp
; ScmSeq': 
; ScmSet':
; VarParam: equal?-loop
; ScmBox':
;ScmVar'(VarParam): equal?-loop
mov rax, qword [rbp + 8 * 4]

MAKE_PAIR(rbx, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
mov qword [rbx + 8 * 1], rax
mov rax, SOB_VOID_ADDRESS
mov qword [rbp + 32], rax
mov rax, SOB_VOID_ADDRESS
; ScmBoxSet':
; ScmLambdaSimple': 
; Params: x, y
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params256

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop256:
cmp rsi, 1
je end_copy_env_loop256
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop256
end_copy_env_loop256:

add_zero_rib_params256:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop256:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop256
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop256
end_copy_params_loop256:
MAKE_CLOSURE(rax, rdx, Lcode256)
jmp Lcont256
Lcode256:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): rational?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure259
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure259:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse258
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): rational?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 2]
cmp byte [rax], T_CLOSURE
je is_closure260
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure260:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
jmp Lexit258
Lelse258:
; ScmConst':
mov rax, const_tbl + 2
Lexit258:
cmp rax, SOB_FALSE_ADDRESS
je Lelse257
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): =
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure261
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure261:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop261:
cmp rsi, 56
je end_copy_stack_loop261
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop261
end_copy_stack_loop261:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit257
Lelse257:
; ScmIf': 
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): flonum?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure264
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure264:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse263
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): flonum?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 3]
cmp byte [rax], T_CLOSURE
je is_closure265
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure265:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
jmp Lexit263
Lelse263:
; ScmConst':
mov rax, const_tbl + 2
Lexit263:
cmp rax, SOB_FALSE_ADDRESS
je Lelse262
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): =
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure266
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure266:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop266:
cmp rsi, 56
je end_copy_stack_loop266
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop266
end_copy_stack_loop266:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit262
Lelse262:
; ScmIf': 
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): char?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]
cmp byte [rax], T_CLOSURE
je is_closure269
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure269:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse268
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): char?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 5]
cmp byte [rax], T_CLOSURE
je is_closure270
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure270:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
jmp Lexit268
Lelse268:
; ScmConst':
mov rax, const_tbl + 2
Lexit268:
cmp rax, SOB_FALSE_ADDRESS
je Lelse267
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): char->integer
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 10]
cmp byte [rax], T_CLOSURE
je is_closure272
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure272:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): char->integer
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 10]
cmp byte [rax], T_CLOSURE
je is_closure273
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure273:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmVar'(VarBound): =
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure271
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure271:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop271:
cmp rsi, 56
je end_copy_stack_loop271
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop271
end_copy_stack_loop271:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit267
Lelse267:
; ScmIf': 
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): pair?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure276
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure276:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse275
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): pair?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure277
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure277:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
jmp Lexit275
Lelse275:
; ScmConst':
mov rax, const_tbl + 2
Lexit275:
cmp rax, SOB_FALSE_ADDRESS
je Lelse274
; ScmIf': 
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 8]
cmp byte [rax], T_CLOSURE
je is_closure280
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure280:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): car
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 8]
cmp byte [rax], T_CLOSURE
je is_closure281
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure281:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): equal?-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure279
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure279:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse278
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 9]
cmp byte [rax], T_CLOSURE
je is_closure283
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure283:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): cdr
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 9]
cmp byte [rax], T_CLOSURE
je is_closure284
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure284:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): equal?-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure282
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure282:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop282:
cmp rsi, 56
je end_copy_stack_loop282
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop282
end_copy_stack_loop282:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit278
Lelse278:
; ScmConst':
mov rax, const_tbl + 2
Lexit278:
jmp Lexit274
Lelse274:
; ScmIf': 
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): string?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 6]
cmp byte [rax], T_CLOSURE
je is_closure287
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure287:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse286
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): string?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 6]
cmp byte [rax], T_CLOSURE
je is_closure288
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure288:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
jmp Lexit286
Lelse286:
; ScmConst':
mov rax, const_tbl + 2
Lexit286:
cmp rax, SOB_FALSE_ADDRESS
je Lelse285
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]

push rax
push 1
; ScmVar'(VarBound): string->list
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure290
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure290:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmApplic': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): string->list
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure291
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure291:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 2
; ScmBoxGet':
; ScmVar'(VarBound): equal?-loop
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
CAR rax, rax
cmp byte [rax], T_CLOSURE
je is_closure289
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure289:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop289:
cmp rsi, 56
je end_copy_stack_loop289
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop289
end_copy_stack_loop289:
add rsp, rdi
pop rbp
jmp rax
jmp Lexit285
Lelse285:
; ScmApplicTP': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 5]
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarBound): eq?
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 7]
cmp byte [rax], T_CLOSURE
je is_closure292
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure292:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop292:
cmp rsi, 56
je end_copy_stack_loop292
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop292
end_copy_stack_loop292:
add rsp, rdi
pop rbp
jmp rax
Lexit285:
Lexit274:
Lexit267:
Lexit262:
Lexit257:
leave
ret
Lcont256:
mov rbx, rax
;ScmVar'(VarParam): equal?-loop
mov rax, qword [rbp + 8 * 4]
mov qword [rax + 8 * 1], rbx
mov rax, SOB_VOID_ADDRESS
; ScmBoxGet':
;ScmVar'(VarParam): equal?-loop
mov rax, qword [rbp + 8 * 4]
CAR rax, rax
leave
ret
Lcont255:
cmp byte [rax], T_CLOSURE
je is_closure254
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure254:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop254:
cmp rsi, 48
je end_copy_stack_loop254
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop254
end_copy_stack_loop254:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont253:
cmp byte [rax], T_CLOSURE
je is_closure252
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure252:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 160], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmDef':
; VarFree: fact
; ScmApplic': 
; ScmApplic': 
; ScmLambdaSimple': 
; Params: ->
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1077

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1077:
cmp rsi, -1
je end_copy_env_loop1077
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1077
end_copy_env_loop1077:

add_zero_rib_params1077:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1077:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1077
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1077
end_copy_params_loop1077:
MAKE_CLOSURE(rax, rdx, Lcode1077)
jmp Lcont1077
Lcode1077:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: n
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1078

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1078:
cmp rsi, 0
je end_copy_env_loop1078
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1078
end_copy_env_loop1078:

add_zero_rib_params1078:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1078:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1078
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1078
end_copy_params_loop1078:
MAKE_CLOSURE(rax, rdx, Lcode1078)
jmp Lcont1078
Lcode1078:
push rbp
mov rbp , rsp
; ScmIf': 
; ScmApplic': 
;ScmVar'(VarParam): n
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarFree): zero?
mov rax, qword [fvar_tbl + 392]
cmp byte [rax], T_CLOSURE
je is_closure1080
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1080:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse1079
; ScmLambdaSimple': 
; Params: x
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1081

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1081:
cmp rsi, 1
je end_copy_env_loop1081
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1081
end_copy_env_loop1081:

add_zero_rib_params1081:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1081:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1081
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1081
end_copy_params_loop1081:
MAKE_CLOSURE(rax, rdx, Lcode1081)
jmp Lcont1081
Lcode1081:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: y
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1082

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1082:
cmp rsi, 2
je end_copy_env_loop1082
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1082
end_copy_env_loop1082:

add_zero_rib_params1082:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1082:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1082
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1082
end_copy_params_loop1082:
MAKE_CLOSURE(rax, rdx, Lcode1082)
jmp Lcont1082
Lcode1082:
push rbp
mov rbp , rsp
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 4]
leave
ret
Lcont1082:
leave
ret
Lcont1081:
jmp Lexit1079
Lelse1079:
; ScmApplicTP': 
; ScmApplic': 
; ScmApplic': 
; ScmConst':
mov rax, const_tbl + 51
push rax
;ScmVar'(VarParam): n
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarFree): -
mov rax, qword [fvar_tbl + 32]
cmp byte [rax], T_CLOSURE
je is_closure1092
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1092:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmVar'(VarBound): ->
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): ->
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1091
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1091:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1090
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1090:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmLambdaSimple': 
; Params: z
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1084

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1084:
cmp rsi, 1
je end_copy_env_loop1084
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1084
end_copy_env_loop1084:

add_zero_rib_params1084:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1084:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1084
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1084
end_copy_params_loop1084:
MAKE_CLOSURE(rax, rdx, Lcode1084)
jmp Lcont1084
Lcode1084:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: x
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1085

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1085:
cmp rsi, 2
je end_copy_env_loop1085
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1085
end_copy_env_loop1085:

add_zero_rib_params1085:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1085:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1085
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1085
end_copy_params_loop1085:
MAKE_CLOSURE(rax, rdx, Lcode1085)
jmp Lcont1085
Lcode1085:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: y
mov rdx, 5
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1086

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1086:
cmp rsi, 3
je end_copy_env_loop1086
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1086
end_copy_env_loop1086:

add_zero_rib_params1086:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1086:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1086
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1086
end_copy_params_loop1086:
MAKE_CLOSURE(rax, rdx, Lcode1086)
jmp Lcont1086
Lcode1086:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): y
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): z
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1089
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1089:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1088
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1088:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1087
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1087:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop1087:
cmp rsi, 48
je end_copy_stack_loop1087
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop1087
end_copy_stack_loop1087:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont1086:
leave
ret
Lcont1085:
leave
ret
Lcont1084:
cmp byte [rax], T_CLOSURE
je is_closure1083
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1083:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop1083:
cmp rsi, 48
je end_copy_stack_loop1083
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop1083
end_copy_stack_loop1083:
add rsp, rdi
pop rbp
jmp rax
Lexit1079:
leave
ret
Lcont1078:
leave
ret
Lcont1077:

push rax
push 1
; ScmLambdaSimple': 
; Params: x
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1075

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1075:
cmp rsi, -1
je end_copy_env_loop1075
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1075
end_copy_env_loop1075:

add_zero_rib_params1075:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1075:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1075
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1075
end_copy_params_loop1075:
MAKE_CLOSURE(rax, rdx, Lcode1075)
jmp Lcont1075
Lcode1075:
push rbp
mov rbp , rsp
; ScmApplicTP': 
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 1
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure1076
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1076:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop1076:
cmp rsi, 48
je end_copy_stack_loop1076
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop1076
end_copy_stack_loop1076:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont1075:
cmp byte [rax], T_CLOSURE
je is_closure1074
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1074:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
push rax
; ScmLambdaSimple': 
; Params: x
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1093

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1093:
cmp rsi, -1
je end_copy_env_loop1093
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1093
end_copy_env_loop1093:

add_zero_rib_params1093:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1093:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1093
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1093
end_copy_params_loop1093:
MAKE_CLOSURE(rax, rdx, Lcode1093)
jmp Lcont1093
Lcode1093:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmLambdaSimple': 
; Params: x
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1102

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1102:
cmp rsi, 0
je end_copy_env_loop1102
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1102
end_copy_env_loop1102:

add_zero_rib_params1102:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1102:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1102
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1102
end_copy_params_loop1102:
MAKE_CLOSURE(rax, rdx, Lcode1102)
jmp Lcont1102
Lcode1102:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: y
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1103

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1103:
cmp rsi, 1
je end_copy_env_loop1103
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1103
end_copy_env_loop1103:

add_zero_rib_params1103:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1103:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1103
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1103
end_copy_params_loop1103:
MAKE_CLOSURE(rax, rdx, Lcode1103)
jmp Lcont1103
Lcode1103:
push rbp
mov rbp , rsp
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
leave
ret
Lcont1103:
leave
ret
Lcont1102:

push rax
push 1
; ScmApplic': 
; ScmLambdaSimple': 
; Params: x
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1096

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1096:
cmp rsi, 0
je end_copy_env_loop1096
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1096
end_copy_env_loop1096:

add_zero_rib_params1096:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1096:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1096
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1096
end_copy_params_loop1096:
MAKE_CLOSURE(rax, rdx, Lcode1096)
jmp Lcont1096
Lcode1096:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: y
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1097

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1097:
cmp rsi, 1
je end_copy_env_loop1097
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1097
end_copy_env_loop1097:

add_zero_rib_params1097:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1097:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1097
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1097
end_copy_params_loop1097:
MAKE_CLOSURE(rax, rdx, Lcode1097)
jmp Lcont1097
Lcode1097:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: z
mov rdx, 4
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1098

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1098:
cmp rsi, 2
je end_copy_env_loop1098
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1098
end_copy_env_loop1098:

add_zero_rib_params1098:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1098:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1098
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1098
end_copy_params_loop1098:
MAKE_CLOSURE(rax, rdx, Lcode1098)
jmp Lcont1098
Lcode1098:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmApplic': 
;ScmVar'(VarParam): z
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): y
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1101
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1101:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
;ScmVar'(VarParam): z
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 1]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1100
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1100:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1099
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1099:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop1099:
cmp rsi, 48
je end_copy_stack_loop1099
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop1099
end_copy_stack_loop1099:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont1098:
leave
ret
Lcont1097:
leave
ret
Lcont1096:

push rax
push 1
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure1095
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1095:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1094
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1094:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop1094:
cmp rsi, 48
je end_copy_stack_loop1094
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop1094
end_copy_stack_loop1094:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont1093:

push rax
push 2
; ScmLambdaSimple': 
; Params: x, ->
mov rdx, 1
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params294

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop294:
cmp rsi, -1
je end_copy_env_loop294
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop294
end_copy_env_loop294:

add_zero_rib_params294:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop294:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop294
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop294
end_copy_params_loop294:
MAKE_CLOSURE(rax, rdx, Lcode294)
jmp Lcont294
Lcode294:
push rbp
mov rbp , rsp
; ScmLambdaSimple': 
; Params: n
mov rdx, 2
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params295

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop295:
cmp rsi, 0
je end_copy_env_loop295
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop295
end_copy_env_loop295:

add_zero_rib_params295:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop295:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop295
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop295
end_copy_params_loop295:
MAKE_CLOSURE(rax, rdx, Lcode295)
jmp Lcont295
Lcode295:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 34

push rax
push 1
; ScmApplic': 
; ScmLambdaSimple': 
; Params: x
mov rdx, 3
shl rdx, 3 ; number_of_environments * 8 bytes
MALLOC rdx, rdx
mov rbx, [rbp + 8 * 2]
cmp rbx, SOB_NIL_ADDRESS
je add_zero_rib_params1072

mov rsi, 0 ; i=0
mov rdi, 1 ; j=1
copy_env_loop1072:
cmp rsi, 1
je end_copy_env_loop1072
mov rcx, [rbx + 8 * rsi]
mov qword [rdx + 8 * rdi], rcx
inc rsi
inc rdi
jmp copy_env_loop1072
end_copy_env_loop1072:

add_zero_rib_params1072:
mov rcx, [rbp + 8 * 3]
shl rcx, 3 ; number of params * 8 bytes
MALLOC rcx, rcx
mov qword [rdx + 8 * 0], rcx
mov rdi, 0 ; i=0
copy_params_loop1072:
cmp rdi, [rbp + 8 * 3]
je end_copy_params_loop1072
mov rbx, [rbp + 8 * (4 + rdi)]
mov qword [rcx + 8 * rdi], rbx
inc rdi
jmp copy_params_loop1072
end_copy_params_loop1072:
MAKE_CLOSURE(rax, rdx, Lcode1072)
jmp Lcont1072
Lcode1072:
push rbp
mov rbp , rsp
; ScmApplicTP': 
; ScmConst':
mov rax, const_tbl + 51
push rax
;ScmVar'(VarParam): x
mov rax, qword [rbp + 8 * 4]

push rax
push 2
; ScmVar'(VarFree): +
mov rax, qword [fvar_tbl + 24]
cmp byte [rax], T_CLOSURE
je is_closure1073
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1073:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop1073:
cmp rsi, 56
je end_copy_stack_loop1073
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop1073
end_copy_stack_loop1073:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont1072:

push rax
push 1
; ScmApplic': 
; ScmApplic': 
;ScmVar'(VarParam): n
mov rax, qword [rbp + 8 * 4]

push rax
push 1
; ScmVar'(VarBound): ->
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 1]
cmp byte [rax], T_CLOSURE
je is_closure1071
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1071:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1070
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1070:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1069
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1069:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1068
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1068:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1067
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1067:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1066
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1066:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1065
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1065:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1064
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1064:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1063
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1063:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1062
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1062:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1061
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1061:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1060
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1060:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1059
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1059:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1058
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1058:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1057
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1057:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1056
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1056:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1055
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1055:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1054
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1054:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1053
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1053:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1052
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1052:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1051
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1051:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1050
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1050:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1049
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1049:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1048
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1048:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1047
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1047:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1046
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1046:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1045
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1045:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1044
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1044:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1043
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1043:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1042
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1042:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1041
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1041:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1040
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1040:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1039
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1039:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1038
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1038:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1037
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1037:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1036
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1036:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1035
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1035:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1034
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1034:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1033
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1033:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1032
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1032:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1031
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1031:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1030
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1030:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1029
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1029:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1028
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1028:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1027
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1027:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1026
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1026:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1025
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1025:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1024
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1024:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1023
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1023:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1022
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1022:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1021
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1021:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1020
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1020:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1019
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1019:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1018
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1018:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1017
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1017:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1016
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1016:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1015
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1015:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1014
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1014:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1013
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1013:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1012
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1012:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1011
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1011:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1010
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1010:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1009
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1009:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1008
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1008:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1007
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1007:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1006
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1006:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1005
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1005:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1004
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1004:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1003
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1003:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1002
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1002:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure1001
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1001:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure1000
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1000:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure999
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure999:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure998
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure998:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure997
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure997:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure996
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure996:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure995
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure995:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure994
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure994:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure993
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure993:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure992
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure992:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure991
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure991:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure990
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure990:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure989
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure989:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure988
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure988:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure987
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure987:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure986
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure986:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure985
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure985:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure984
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure984:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure983
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure983:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure982
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure982:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure981
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure981:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure980
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure980:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure979
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure979:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure978
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure978:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure977
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure977:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure976
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure976:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure975
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure975:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure974
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure974:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure973
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure973:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure972
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure972:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure971
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure971:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure970
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure970:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure969
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure969:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure968
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure968:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure967
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure967:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure966
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure966:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure965
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure965:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure964
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure964:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure963
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure963:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure962
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure962:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure961
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure961:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure960
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure960:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure959
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure959:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure958
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure958:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure957
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure957:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure956
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure956:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure955
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure955:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure954
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure954:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure953
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure953:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure952
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure952:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure951
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure951:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure950
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure950:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure949
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure949:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure948
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure948:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure947
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure947:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure946
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure946:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure945
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure945:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure944
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure944:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure943
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure943:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure942
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure942:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure941
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure941:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure940
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure940:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure939
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure939:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure938
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure938:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure937
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure937:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure936
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure936:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure935
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure935:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure934
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure934:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure933
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure933:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure932
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure932:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure931
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure931:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure930
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure930:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure929
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure929:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure928
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure928:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure927
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure927:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure926
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure926:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure925
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure925:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure924
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure924:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure923
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure923:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure922
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure922:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure921
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure921:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure920
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure920:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure919
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure919:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure918
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure918:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure917
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure917:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure916
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure916:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure915
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure915:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure914
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure914:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure913
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure913:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure912
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure912:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure911
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure911:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure910
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure910:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure909
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure909:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure908
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure908:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure907
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure907:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure906
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure906:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure905
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure905:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure904
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure904:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure903
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure903:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure902
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure902:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure901
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure901:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure900
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure900:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure899
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure899:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure898
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure898:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure897
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure897:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure896
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure896:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure895
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure895:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure894
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure894:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure893
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure893:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure892
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure892:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure891
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure891:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure890
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure890:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure889
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure889:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure888
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure888:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure887
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure887:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure886
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure886:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure885
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure885:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure884
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure884:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure883
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure883:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure882
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure882:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure881
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure881:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure880
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure880:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure879
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure879:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure878
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure878:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure877
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure877:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure876
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure876:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure875
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure875:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure874
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure874:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure873
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure873:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure872
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure872:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure871
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure871:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure870
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure870:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure869
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure869:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure868
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure868:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure867
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure867:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure866
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure866:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure865
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure865:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure864
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure864:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure863
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure863:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure862
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure862:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure861
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure861:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure860
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure860:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure859
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure859:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure858
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure858:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure857
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure857:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure856
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure856:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure855
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure855:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure854
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure854:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure853
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure853:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure852
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure852:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure851
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure851:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure850
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure850:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure849
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure849:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure848
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure848:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure847
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure847:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure846
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure846:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure845
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure845:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure844
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure844:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure843
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure843:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure842
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure842:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure841
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure841:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure840
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure840:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure839
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure839:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure838
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure838:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure837
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure837:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure836
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure836:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure835
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure835:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure834
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure834:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure833
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure833:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure832
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure832:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure831
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure831:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure830
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure830:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure829
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure829:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure828
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure828:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure827
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure827:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure826
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure826:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure825
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure825:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure824
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure824:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure823
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure823:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure822
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure822:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure821
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure821:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure820
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure820:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure819
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure819:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure818
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure818:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure817
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure817:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure816
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure816:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure815
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure815:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure814
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure814:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure813
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure813:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure812
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure812:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure811
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure811:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure810
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure810:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure809
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure809:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure808
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure808:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure807
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure807:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure806
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure806:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure805
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure805:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure804
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure804:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure803
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure803:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure802
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure802:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure801
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure801:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure800
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure800:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure799
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure799:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure798
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure798:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure797
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure797:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure796
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure796:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure795
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure795:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure794
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure794:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure793
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure793:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure792
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure792:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure791
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure791:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure790
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure790:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure789
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure789:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure788
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure788:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure787
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure787:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure786
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure786:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure785
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure785:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure784
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure784:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure783
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure783:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure782
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure782:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure781
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure781:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure780
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure780:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure779
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure779:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure778
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure778:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure777
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure777:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure776
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure776:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure775
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure775:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure774
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure774:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure773
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure773:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure772
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure772:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure771
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure771:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure770
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure770:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure769
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure769:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure768
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure768:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure767
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure767:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure766
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure766:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure765
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure765:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure764
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure764:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure763
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure763:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure762
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure762:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure761
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure761:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure760
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure760:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure759
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure759:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure758
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure758:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure757
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure757:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure756
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure756:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure755
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure755:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure754
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure754:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure753
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure753:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure752
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure752:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure751
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure751:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure750
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure750:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure749
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure749:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure748
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure748:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure747
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure747:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure746
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure746:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure745
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure745:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure744
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure744:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure743
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure743:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure742
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure742:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure741
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure741:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure740
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure740:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure739
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure739:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure738
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure738:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure737
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure737:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure736
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure736:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure735
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure735:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure734
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure734:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure733
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure733:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure732
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure732:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure731
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure731:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure730
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure730:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure729
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure729:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure728
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure728:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure727
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure727:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure726
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure726:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure725
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure725:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure724
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure724:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure723
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure723:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure722
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure722:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure721
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure721:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure720
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure720:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure719
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure719:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure718
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure718:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure717
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure717:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure716
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure716:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure715
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure715:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure714
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure714:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure713
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure713:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure712
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure712:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure711
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure711:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure710
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure710:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure709
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure709:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure708
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure708:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure707
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure707:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure706
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure706:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure705
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure705:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure704
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure704:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure703
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure703:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure702
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure702:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure701
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure701:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure700
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure700:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure699
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure699:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure698
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure698:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure697
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure697:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure696
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure696:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure695
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure695:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure694
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure694:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure693
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure693:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure692
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure692:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure691
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure691:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure690
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure690:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure689
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure689:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure688
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure688:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure687
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure687:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure686
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure686:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure685
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure685:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure684
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure684:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure683
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure683:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure682
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure682:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure681
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure681:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure680
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure680:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure679
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure679:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure678
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure678:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure677
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure677:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure676
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure676:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure675
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure675:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure674
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure674:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure673
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure673:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure672
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure672:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure671
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure671:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure670
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure670:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure669
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure669:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure668
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure668:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure667
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure667:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure666
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure666:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure665
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure665:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure664
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure664:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure663
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure663:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure662
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure662:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure661
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure661:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure660
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure660:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure659
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure659:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure658
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure658:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure657
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure657:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure656
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure656:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure655
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure655:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure654
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure654:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure653
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure653:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure652
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure652:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure651
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure651:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure650
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure650:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure649
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure649:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure648
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure648:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure647
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure647:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure646
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure646:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure645
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure645:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure644
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure644:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure643
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure643:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure642
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure642:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure641
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure641:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure640
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure640:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure639
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure639:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure638
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure638:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure637
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure637:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure636
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure636:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure635
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure635:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure634
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure634:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure633
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure633:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure632
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure632:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure631
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure631:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure630
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure630:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure629
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure629:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure628
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure628:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure627
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure627:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure626
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure626:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure625
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure625:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure624
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure624:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure623
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure623:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure622
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure622:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure621
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure621:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure620
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure620:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure619
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure619:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure618
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure618:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure617
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure617:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure616
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure616:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure615
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure615:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure614
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure614:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure613
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure613:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure612
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure612:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure611
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure611:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure610
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure610:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure609
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure609:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure608
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure608:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure607
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure607:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure606
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure606:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure605
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure605:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure604
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure604:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure603
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure603:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure602
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure602:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure601
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure601:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure600
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure600:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure599
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure599:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure598
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure598:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure597
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure597:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure596
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure596:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure595
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure595:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure594
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure594:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure593
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure593:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure592
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure592:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure591
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure591:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure590
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure590:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure589
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure589:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure588
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure588:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure587
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure587:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure586
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure586:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure585
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure585:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure584
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure584:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure583
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure583:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure582
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure582:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure581
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure581:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure580
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure580:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure579
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure579:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure578
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure578:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure577
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure577:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure576
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure576:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure575
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure575:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure574
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure574:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure573
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure573:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure572
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure572:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure571
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure571:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure570
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure570:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure569
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure569:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure568
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure568:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure567
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure567:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure566
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure566:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure565
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure565:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure564
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure564:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure563
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure563:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure562
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure562:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure561
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure561:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure560
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure560:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure559
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure559:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure558
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure558:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure557
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure557:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure556
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure556:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure555
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure555:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure554
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure554:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure553
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure553:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure552
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure552:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure551
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure551:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure550
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure550:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure549
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure549:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure548
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure548:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure547
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure547:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure546
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure546:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure545
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure545:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure544
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure544:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure543
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure543:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure542
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure542:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure541
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure541:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure540
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure540:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure539
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure539:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure538
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure538:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure537
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure537:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure536
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure536:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure535
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure535:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure534
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure534:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure533
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure533:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure532
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure532:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure531
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure531:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure530
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure530:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure529
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure529:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure528
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure528:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure527
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure527:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure526
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure526:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure525
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure525:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure524
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure524:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure523
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure523:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure522
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure522:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure521
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure521:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure520
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure520:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure519
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure519:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure518
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure518:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure517
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure517:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure516
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure516:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure515
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure515:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure514
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure514:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure513
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure513:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure512
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure512:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure511
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure511:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure510
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure510:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure509
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure509:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure508
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure508:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure507
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure507:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure506
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure506:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure505
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure505:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure504
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure504:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure503
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure503:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure502
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure502:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure501
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure501:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure500
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure500:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure499
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure499:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure498
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure498:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure497
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure497:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure496
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure496:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure495
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure495:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure494
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure494:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure493
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure493:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure492
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure492:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure491
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure491:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure490
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure490:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure489
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure489:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure488
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure488:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure487
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure487:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure486
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure486:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure485
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure485:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure484
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure484:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure483
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure483:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure482
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure482:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure481
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure481:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure480
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure480:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure479
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure479:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure478
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure478:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure477
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure477:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure476
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure476:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure475
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure475:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure474
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure474:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure473
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure473:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure472
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure472:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure471
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure471:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure470
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure470:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure469
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure469:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure468
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure468:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure467
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure467:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure466
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure466:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure465
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure465:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure464
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure464:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure463
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure463:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure462
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure462:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure461
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure461:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure460
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure460:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure459
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure459:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure458
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure458:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure457
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure457:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure456
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure456:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure455
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure455:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure454
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure454:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure453
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure453:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure452
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure452:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure451
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure451:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure450
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure450:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure449
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure449:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure448
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure448:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure447
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure447:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure446
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure446:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure445
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure445:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure444
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure444:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure443
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure443:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure442
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure442:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure441
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure441:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure440
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure440:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure439
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure439:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure438
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure438:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure437
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure437:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure436
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure436:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure435
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure435:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure434
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure434:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure433
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure433:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure432
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure432:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure431
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure431:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure430
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure430:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure429
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure429:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure428
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure428:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure427
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure427:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure426
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure426:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure425
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure425:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure424
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure424:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure423
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure423:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure422
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure422:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure421
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure421:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure420
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure420:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure419
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure419:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure418
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure418:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure417
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure417:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure416
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure416:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure415
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure415:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure414
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure414:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure413
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure413:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure412
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure412:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure411
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure411:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure410
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure410:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure409
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure409:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure408
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure408:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure407
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure407:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure406
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure406:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure405
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure405:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure404
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure404:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure403
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure403:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure402
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure402:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure401
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure401:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure400
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure400:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure399
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure399:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure398
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure398:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure397
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure397:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure396
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure396:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure395
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure395:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure394
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure394:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure393
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure393:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure392
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure392:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure391
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure391:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure390
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure390:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure389
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure389:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure388
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure388:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure387
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure387:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure386
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure386:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure385
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure385:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure384
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure384:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure383
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure383:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure382
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure382:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure381
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure381:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure380
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure380:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure379
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure379:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure378
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure378:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure377
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure377:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure376
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure376:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure375
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure375:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure374
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure374:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure373
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure373:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure372
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure372:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure371
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure371:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure370
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure370:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure369
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure369:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure368
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure368:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure367
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure367:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure366
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure366:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure365
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure365:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure364
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure364:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure363
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure363:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure362
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure362:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure361
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure361:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure360
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure360:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure359
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure359:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure358
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure358:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure357
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure357:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure356
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure356:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure355
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure355:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure354
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure354:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure353
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure353:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure352
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure352:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure351
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure351:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure350
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure350:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure349
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure349:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure348
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure348:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure347
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure347:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure346
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure346:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure345
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure345:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure344
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure344:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure343
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure343:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure342
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure342:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure341
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure341:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure340
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure340:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure339
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure339:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure338
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure338:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure337
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure337:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure336
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure336:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure335
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure335:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure334
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure334:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure333
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure333:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure332
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure332:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure331
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure331:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure330
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure330:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure329
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure329:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure328
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure328:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure327
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure327:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure326
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure326:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure325
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure325:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure324
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure324:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure323
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure323:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure322
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure322:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure321
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure321:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure320
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure320:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure319
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure319:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure318
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure318:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure317
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure317:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure316
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure316:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure315
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure315:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure314
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure314:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure313
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure313:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure312
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure312:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure311
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure311:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure310
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure310:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure309
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure309:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure308
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure308:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure307
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure307:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmApplic': 
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure306
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure306:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure305
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure305:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure304
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure304:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

push rax
push 1
; ScmVar'(VarBound): x
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * 0]
mov rax, qword [rax + 8 * 0]
cmp byte [rax], T_CLOSURE
je is_closure303
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure303:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure302
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure302:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure301
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure301:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure300
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure300:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure299
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure299:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure298
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure298:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure297
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure297:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
cmp byte [rax], T_CLOSURE
je is_closure296
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure296:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
copy_stack_loop296:
cmp rsi, 48
je end_copy_stack_loop296
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp copy_stack_loop296
end_copy_stack_loop296:
add rsp, rdi
pop rbp
jmp rax
leave
ret
Lcont295:
leave
ret
Lcont294:
cmp byte [rax], T_CLOSURE
je is_closure293
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure293:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]
mov qword [fvar_tbl + 400], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

; ScmApplic': 
; ScmConst':
mov rax, const_tbl + 85

push rax
push 1
; ScmVar'(VarFree): fact
mov rax, qword [fvar_tbl + 400]
cmp byte [rax], T_CLOSURE
je is_closure1104
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure1104:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rdx, rax
call rdx
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8 * rbx]

	call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 cmpltpd xmm0, xmm1
         movq rsi, xmm0
         cmp rsi, 0
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
         .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	 mov rdx, rax
         cmp rdx, 0
         jge .make_result
         neg rdx
         .make_result:
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret

car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CAR rax, rsi
         pop rbp
         ret

cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CDR rax, rsi
         pop rbp
         ret

cons:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	MAKE_PAIR(rax, rsi, rdi)
         pop rbp
         ret

set_car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov qword [rsi + 8 * 1], rdi
mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

set_cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov qword [rsi + 8 * 2], rdi
mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

apply:
       push rbp
       mov rbp, rsp 
       ; This code is basically the applicTP code
mov rbx, [rbp + 8 * 3] ; number of args on stack
add rbx, 3 ; rbx has the offset of the last argument
shl rbx, 3
add rbx, rsp ; this should point to the list at the end
mov rsi, 0 ; counter of how many args are pushed
cmp qword [rbx], SOB_NIL_ADDRESS
je end_reverse_stack_loop
mov rdx, qword [rbx]
push_the_list_loop:
CAR rax, rdx
push rax ; push car to reverse later
inc rsi
CDR rbx, rdx ; now rbx has the cdr of the list
mov rdx, rbx
cmp qword rbx, SOB_NIL_ADDRESS
jne push_the_list_loop
end_push_the_list_loop:
mov rbx, rbp
sub rbx, 8 * 1 ; copy from
mov rcx, rbp
shl rsi, 3
sub rcx, rsi ; copy to
shr rsi, 3
reverse_stack_loop:
cmp rbx, rcx
jle end_reverse_stack_loop
mov rdx, qword [rbx]
mov rax, qword [rcx]
mov qword [rcx], rdx
mov qword [rbx], rax
sub rbx, 8 * 1
add rcx, 8 * 1
jmp reverse_stack_loop
end_reverse_stack_loop:
mov rdi, [rbp + 8 * 3] ; number of args on stack
sub rdi, 2 ; 1 for list, 1 for proc
cmp rdi, 0
je end_push_stack_args_loop ; no other args to push
add rsi, rdi ; now rsi has all elements on stack
mov rbx, 4
add rbx, rdi
shl rbx, 3
add rbx, rbp ; this should point to the last arg (one before the list)
push_stack_args_loop:
cmp rdi, 0
je end_push_stack_args_loop
mov rax, qword [rbx]
push rax
sub rbx, 8 * 1
dec rdi
jmp push_stack_args_loop
end_push_stack_args_loop:
; now all args should be on the stack
push rsi ; number of args
mov r8, rsi ; have to use general purpose register to hold number of args
mov rax, qword [rbp + 8 * 4]
cmp byte [rax], T_CLOSURE
je is_closure
mov bl, 0
div bl ; divide by zero because rax is not a closure
is_closure:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
mov rax, rbx
push qword [rbp + 8 * 1] ; old ret addr, like practical session 12
push qword [rbp + 8 * 0] ; old rbp, like practical session 12
mov rdi, [rbp + 8 * 3] ; number of arguments on stack
add rdi, 4
shl rdi, 3 ; offset rsp later
mov rsi, 8 * 1 ; i counter
mov rbx, rbp
sub rbx, rsi ; copy from
mov rcx, 3 ; I don't use magic so this is 3 and not 4
add rcx, qword [rbp + 8 * 3]
shl rcx, 3
add rcx, rbp ; copy to
apply_copy_stack_loop:
shl r8, 3
add r8, 8 * 5
cmp rsi, r8
je end_apply_copy_stack_loop
sub r8, 8 * 5
shr r8, 3
mov rdx, qword [rbx]
mov qword [rcx], rdx
sub rbx, 8
sub rcx, 8
add rsi, 8
jmp apply_copy_stack_loop
end_apply_copy_stack_loop:
add rsp, rdi
pop rbp
jmp rax

         pop rbp
         ret